<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.5" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.5">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.5" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.5',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="老特拉福德我的家">
<meta property="og:type" content="website">
<meta property="og:title" content="左路不笑魔王">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="左路不笑魔王">
<meta property="og:description" content="老特拉福德我的家">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="左路不笑魔王">
<meta name="twitter:description" content="老特拉福德我的家">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>左路不笑魔王</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">左路不笑魔王</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">老子想要穿9号</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/LKImageView源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="麻虾儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左路不笑魔王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/LKImageView源码分析/" itemprop="url">LKImageView源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-13T12:05:12+08:00">2018-03-13</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/Tencent/LKImageKit" target="_blank" rel="noopener">LKImageKit是腾讯开源的基于OC的图片管理类的集合框架</a></p>
<p>在项目主页上的README中说明包含了3个模块:</p>
<ul>
<li>加载模块</li>
<li>解码模块</li>
<li>缓存模块</li>
</ul>
<p>我们采用从上到下的分析方式来解析它的代码，首先是最常用的类<code>LKImageView</code></p>
<p>从几个<code>init</code>方法中可以看出来，启动一个<code>LKImageView</code>的代码都需要调用<code>setup</code>方法，在这个方法中其实就是初始化了一个用于展示的<code>imageView</code>实例,并对于一些属性设置了default值，比较简单<br>并且还新建了一个<code>LKImageManager</code>实例，这个会在后边<a href="#imageManager">解释</a><br>既然添加了subview,就看下<code>layoutSubviews</code>方法,看到调用了<code>layoutAndLoad</code>方法。这个方法会根据图片的size,scale在加上屏幕的scale和控件的大小以及contentMode计算出<code>imageView</code>的frame.比如:</p>
<ul>
<li><code>LKImageScaleModeNone</code> 为居中显示图片，使用图片本身的大小 (不会变形)</li>
<li><code>LKImageScaleModeScaleToFill</code> 直接使用控件大小平铺 (可能变形)</li>
<li><code>LKImageScaleModeAspectFit</code> <code>LKImageScaleModeAspectFill</code>都是不会变形的缩放,差距只是在控件和图片本身的宽高比大小比较时选取的基准的不同</li>
</ul>
<p>之后还会调用加载图片的代码，在后边会展开代码来解析.</p>
<p>下一步来看下加载本地图片的时候是怎么做：<br><code>LKImageView</code>overwrite了<code>setImage</code>方法: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setImage:(UIImage *)image</span><br><span class="line">&#123;</span><br><span class="line">    self.loadingImageRequest = nil;</span><br><span class="line">    self.failureImageRequest = nil;</span><br><span class="line">    if (image)</span><br><span class="line">    &#123;</span><br><span class="line">        self.request = [LKImageImageRequest requestWithImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        self.request = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边也算是比较好理解的了。如果传入的图片不是nil，就会新建一个<code>LKImageImageRequest</code>实例并且set给自身的属性</p>
<p>然后再看下<code>LKImageImageRequest</code>这个类的实现，基类是<code>LKImageRequest</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)requestWithImage:(UIImage *)image key:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    LKImageImageRequest *request = [[LKImageImageRequest alloc] init];</span><br><span class="line">    request.image                = image;</span><br><span class="line">    request.keyForLoader         = [NSString stringWithFormat:@&quot;%p&quot;,image];</span><br><span class="line">    request.synchronized         = YES;</span><br><span class="line">    return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本可以确定对于本地图片是同步加载的。不过这个方法里边这key就有点尴尬啦，完全没有用到:(, keyForLoader取的key是这个image的内存地址。<br>在研究这个Request的代码之前我们先回过来看下<code>LKImageView</code>的<code>setRequest</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)setRequest:(LKImageRequest *)request</span><br><span class="line">&#123;</span><br><span class="line">    request.internalProcessorList = self.processorList;</span><br><span class="line">    if (![_request isEqual:request] || _request.error)</span><br><span class="line">    &#123;</span><br><span class="line">        [self.imageManager cancelRequest:_request];</span><br><span class="line">        _request = request;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!_request)</span><br><span class="line">    &#123;</span><br><span class="line">        [self internalSetImage:nil withRequest:nil];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self setNeedsLayout];</span><br><span class="line">    if (!self.delayLoadingImage)</span><br><span class="line">    &#123;</span><br><span class="line">        [self layoutIfNeeded];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>internalProcessorList</code>这个数组是图片的处理模块的processor，就是加特效</p>
<p><img src="/2018/03/13/LKImageView源码分析/timg.jpeg" alt="特效"></p>
<p>代码中看到的就是blur和gray两个东西</p>
<p>然后看如果原先的request和设置的新的requset不是相同的或者原先的请求出现error的话就会走到imageManager cacheRequest的代码。这块先略过<br>然后就会发现代码调用了<code>setNeedsLayout</code>和<code>layoutIfNeeded</code>方法，这个时候就会回到上边说的<code>layoutSubviews</code>方法和<code>layoutAndLoad</code>了，我们上面没有展开这个代码，只是说了frame的变化。现在详细展开之后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutAndLoad</span><br><span class="line">&#123;</span><br><span class="line">    [self layoutImageView];</span><br><span class="line">    if (self.request.state == LKImageRequestStateFinish</span><br><span class="line">        &amp;&amp;!CGSizeEqualToSize(self.oldSize, self.size)</span><br><span class="line">        &amp;&amp;(!self.presentationImage||self.presentationImage.lk_isScaled))</span><br><span class="line">    &#123;</span><br><span class="line">        [self.request reset];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.request &amp;&amp; self.request.state == LKImageRequestStateInit)</span><br><span class="line">    &#123;</span><br><span class="line">        self.oldSize = self.size;</span><br><span class="line"></span><br><span class="line">        __weak LKImageView *wself = self;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        if (!self.request.synchronized)</span><br><span class="line">        &#123;</span><br><span class="line">            if (self.loadingImageRequest)</span><br><span class="line">            &#123;</span><br><span class="line">                [self dealWithRequest:self.loadingImageRequest];</span><br><span class="line">                [self.imageManager sendRequest:self.loadingImageRequest</span><br><span class="line">                                    completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123;</span><br><span class="line">                                        [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache];</span><br><span class="line">                                    &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self dealWithRequest:self.request];</span><br><span class="line">        [self.imageManager sendRequest:self.request</span><br><span class="line">                            completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123;</span><br><span class="line">                                [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache];</span><br><span class="line">                            &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步是上面说过的计算imageView的frame的代码,剩余的代码是对request的操作,<br>假设我们第一次调用这个方法也就是说这个request刚刚被alloc出来，所以这个时候<code>state==LKImageRequestStateInit</code>，所以走不到reset，其实reset相当于情况状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset</span><br><span class="line">&#123;</span><br><span class="line">    self.error                        = nil;</span><br><span class="line">    self.progress                     = 0;</span><br><span class="line">    self.isCanceled                   = NO;</span><br><span class="line">    self.isStarted                    = NO;</span><br><span class="line">    self.isFinished                   = NO;</span><br><span class="line">    self.imageManagerCancelOperation  = nil;</span><br><span class="line">    self.loaderManagerCancelOperation = nil;</span><br><span class="line">    self.decodeOperation              = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在的状态是符合第二个if的条件的。然后我们的requeset是一个synchronized的请求。暂时可以不用管异步的地方，只要看之后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[self dealWithRequest:self.request];</span><br><span class="line">[self.imageManager sendRequest:self.request</span><br><span class="line"> completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123;</span><br><span class="line">   		[wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>先看<code>dealWithRequst:</code> 这个和上边的特效是一样的，添加特效的processers。然后还设置了preferredSize为控件的大小<br><a name="imageManager">再看下</a><code>imageManager sendRequest</code>这一句。在<code>setup</code>方法中设置了一个defalut的imageManager.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)defaultManager</span><br><span class="line">&#123;</span><br><span class="line">    static LKImageManager *instance = nil;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance                  = [[self alloc] initWithConfiguration:nil];</span><br><span class="line">        instance.cacheManager     = [LKImageCacheManager defaultManager];</span><br><span class="line">        instance.loaderManager    = [LKImageLoaderManager defaultManager];</span><br><span class="line">        instance.processorManager = [LKImageProcessorManager defaultManager];</span><br><span class="line">        [instance setConfiguration:[LKImageConfiguration defaultConfiguration]];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看这个cacheManager.<code>LKImageCacheManager</code>维护了一个<code>LKImageCache</code>的实例的数组。看过源码发现。这个是一个基类,有两个个不同的实现类<code>LKImageMemoryCache</code>,<code>LKImageSmartCache</code>,不过你也定义自己的Cache类型。<br>在<code>LKImageManager</code>的<code>- (void)setConfiguration:(LKImageConfiguration *)configuration</code>方法中添加了对应的Cache:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LKImageCacheManager *cacheManager = self.cacheManager;</span><br><span class="line">   [cacheManager unregisterAllCache];</span><br><span class="line">   for (LKImageCache *cache in configuration.cacheList)</span><br><span class="line">   &#123;</span><br><span class="line">       [cacheManager registerCache:cache];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>而在<code>LKImageCacheManager</code>中的<code>- (void)cacheImage:(UIImage *)image forRequest:(LKImageRequest *)request</code>中就是调用了对用的Cache列表的对应的Cache方法，<code>LKImageCache</code>的子类来实现自己的<code>- (void)cacheImage:(UIImage *)image forRequest:(LKImageRequest *)request</code>方法就行了。<br>我们来看下LKImageKit本身提供的两个Cache的方法:</p>
<h3 id="LKImageMemoryCache"><a href="#LKImageMemoryCache" class="headerlink" title="LKImageMemoryCache"></a>LKImageMemoryCache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)cacheImage:(UIImage *)image URL:(NSString *)URL</span><br><span class="line">&#123;</span><br><span class="line">    NSString *key     = [self keyForURL:URL];</span><br><span class="line">    ImagePointer *ptr = NULL;</span><br><span class="line">    auto it           = imageMap.find([key cStringUsingEncoding:NSUTF8StringEncoding]);</span><br><span class="line">    if (it == imageMap.end())</span><br><span class="line">    &#123;</span><br><span class="line">        ImageNode *node     = new ImageNode();</span><br><span class="line">        ptr                 = new ImagePointer();</span><br><span class="line">        node-&gt;image         = image;</span><br><span class="line">        node-&gt;key           = [key cStringUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        ptr-&gt;it             = FIFOQueue.insert(FIFOQueue.end(), node);</span><br><span class="line">        imageMap[node-&gt;key] = ptr;</span><br><span class="line">        if (FIFOQueue.size() &gt; self.maxLengthForFIFO)</span><br><span class="line">        &#123;</span><br><span class="line">            ImageNode *node = *FIFOQueue.begin();</span><br><span class="line">            FIFOQueue.pop_front();</span><br><span class="line">            auto it = imageMap.find(node-&gt;key);</span><br><span class="line">            delete it-&gt;second;</span><br><span class="line">            delete node;</span><br><span class="line">            imageMap.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ptr               = it-&gt;second;</span><br><span class="line">        (*ptr-&gt;it)-&gt;image = image;</span><br><span class="line">        [self visit:key];</span><br><span class="line">    &#125;</span><br><span class="line">    [self limitCacheSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类中可以看到一个<code>map&lt;string,ImagePointer *&gt; imageMap</code>实例。在<code>- (void)cacheImage:(UIImage *)image URL:(NSString *)URL</code>中用图片的地址当做key来在map中寻找对应的ImagePointer指针，如果没有找到，就新建一个<code>ImageNode</code>和<code>ImagePointer</code>指针，设置node的image为image,然后在<code>FIFOQueue</code>的列表的尾部添加这个node。然后查看队列的大小时候超出了预定的阈值,如果超过就按照先进先出的策略pop掉第一个，并且在map中也删除掉这个迭代器类型的数据。同事在堆上把node和pointer都free掉。</p>
<p>这边其实基本可以看出map和list的作用了，map是为在O(1)的时间复杂度内找到对应的数据。而list是为了控制缓存的大小.</p>
<p>然后在看下如果map中存在这个key的时候的操作。就是更新下这个key对应的图片，然后调用visit方法，最后调用<code>limitCacheSize</code>方法</p>
<p>先看下visit方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)visit:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    auto it = imageMap.find([key cStringUsingEncoding:NSUTF8StringEncoding]);</span><br><span class="line">    if (it == imageMap.end())</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ImagePointer *ptr = it-&gt;second;</span><br><span class="line">    ImageNode *node   = *ptr-&gt;it;</span><br><span class="line">    if (ptr-&gt;isLRUQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        LRUQueue.erase(ptr-&gt;it);</span><br><span class="line">        ptr-&gt;it = LRUQueue.insert(LRUQueue.end(), node);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ptr-&gt;isLRUQueue = true;</span><br><span class="line">        FIFOQueue.erase(ptr-&gt;it);</span><br><span class="line">        ptr-&gt;it = LRUQueue.insert(LRUQueue.end(), node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (LRUQueue.size() &gt; self.maxLengthForLRU)</span><br><span class="line">    &#123;</span><br><span class="line">        [self clearLastOneInLRU];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候先查看这个ImagePointer的Node是不是在LRUQueue这个列表里边，如果在的话就删除之后再插入到列表的最后去，如果不在的话就在FIFOQueue中删除掉这个node,重新加入到LRUQueue中去，之后再根据LRUQueue的大小来clean下,我们也能想到既然最新visit的是放到最尾部，那么做clean操作的时候肯定就是清除头部了.</p>
<p>然后我们看下limitCacheSize方法,同样的是很简单的根据map中缓存的图片的尺寸x4之后的大小来和阈值比较，在做情况LRUQueue和FIFOQueue的操作。</p>
<p>这样的话，我们也是能简单的想到LRUQueue的作用了，其实就是一层保证越是后边被使用的图片越是不容易被从缓存中清除出去的机制。<br>不过这边代码里边有个疑问的地方在清除数据的时候会先清除LRUQueue：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearLastOne</span><br><span class="line">&#123;</span><br><span class="line">    if (LRUQueue.size() &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        [self clearLastOneInLRU];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        [self clearLastOneInFIFO];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 感觉上是先FIFOQueue是不是更好一点，毕竟在FIFO中的图片按代码来说只是被用了一次。哪位大佬了解的可以说下 </strong></p>
<h3 id="LKImageSmartCache"><a href="#LKImageSmartCache" class="headerlink" title="LKImageSmartCache"></a>LKImageSmartCache</h3><p>这个比较简单，说使用一个<code>NSMapTable</code>来管理缓存数据就不多说了。</p>
<p>缓存的逻辑基本就是这样啦。好像在这边并没有看到README中所说的磁盘缓存<br><img src="/2018/03/13/LKImageView源码分析/lkimagekit_cache.png" alt="图片缓存目录"></p>
<p>在看下图片加载的代码,主要是看看发送请求的代码(这边的请求不一定是网络请求。是对图片加载的一种封装，可以想象成操作系统对IO的封装一样)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.imageManager sendRequest:self.request</span><br><span class="line">                            completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123;</span><br><span class="line">                                [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache];</span><br><span class="line">                            &#125;];</span><br></pre></td></tr></table></figure>
<p>这个方法正如他的category写的那样是一个<a name="managercallback">语法糖</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendRequest:(LKImageRequest *)request completion:(LKImageManagerCallback)callback</span><br><span class="line">&#123;</span><br><span class="line">    request.managerCallback = callback;</span><br><span class="line">    [self sendRequest:request];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在sendRequest方法中可以看到调用了<code>- (BOOL)checkAndLoadCache:(LKImageRequest *)requestLV0</code>这个方法来加载缓存。我们会看到会在mainqueue中同步的运行block.这边可以看到一个GCD的方法<code>if (dispatch_queue_get_label(queue) == dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL))</code>,用于判断当前的queue是否是指定的queue.<br>然后在block中会调用CacheManager的<code>- (UIImage *)imageForRequest:(LKImageRequest *)request continueLoad:(BOOL *)continueLoad</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)imageForRequest:(LKImageRequest *)request continueLoad:(BOOL *)continueLoad</span><br><span class="line">&#123;</span><br><span class="line">    UIImage *image = nil;</span><br><span class="line">    for (LKImageCache *cache in self.cacheList)</span><br><span class="line">    &#123;</span><br><span class="line">        image = [cache imageForRequest:request continueLoad:continueLoad];</span><br><span class="line">        if (image)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出其实就是在配置的CacheList中来查找对应的图片了，对应的实现就是也比较简单了，比如MemoryCache就是在map中find这个key对应的数据，SmartCache就是在NSMapTable中找对用的数据,不过这边的continuedLoad参数在源码中提供的两个Cache中都是没有被使用的参数，不知道是什么考虑。获取到缓存之后就会调用request的managerCallback这个block(<a href="#managercallback">就是用户传入的回调</a>),同时还会把childRequests的callback也调用一遍，这个requestlist我们以后再来分析:)</p>
<p>到目前为止基本分析完了缓存这块的内容啦。</p>
<p>以后会分下下LKImageRequest和他的子类</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/B站AV号转音频程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="麻虾儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左路不笑魔王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/B站AV号转音频程序/" itemprop="url">B站AV号转音频程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-09T15:36:28+08:00">2018-03-09</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上B站的时候有好多弹幕都是在求BGM的。于是就想不如咱自己写一个东西来分离视频里边的音视频。把音频给抽出来：)</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基本想法就是分成3步来做啦</p>
<ul>
<li>准备阶段—&gt;通过av号获取到视频的地址</li>
<li>下载阶段—&gt;获取到下载地址之后下载视频</li>
<li>分离阶段—&gt;分离视频中的音频保存到单独的文件</li>
</ul>
<p>很简单明确。然后就是找对用的技术啦，最主要的就是分离阶段的技术。我这边选择ffmpeg, 通用的解决方案啦。然后既然是用ffmpeg就要用c/c++来实现比较方便了。最终确定的方案就是这样的:</p>
<ul>
<li>网络请求—&gt; <a href="https://curl.haxx.se/libcurl/" target="_blank" rel="noopener">cURL</a></li>
<li>JSON —&gt; <a href="https://github.com/Tencent/rapidjson" target="_blank" rel="noopener">rapidjson</a></li>
<li>音视频 —&gt;<a href="http://ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a></li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul>
<li>ffmpeg 下载，make ， make install</li>
<li>建立CMakeList.txt 我是在mac上写的。所有需要加上一些变量，下边的是我的cmakelist文件</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(BiliBg)</span><br><span class="line"><span class="comment">#mac/ios build need add some xcode lib</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"$&#123;CMAKE_CXX_FLAGS&#125; -v -std=c++11 -stdlib=libc++ -framework OpenGL -framework AppKit -framework Security -framework CoreFoundation -framework CoreVideo -framework CoreMedia -framework QuartzCore -framework CoreFoundation -framework VideoDecodeAcceleration -framework Cocoa -framework AudioToolbox -framework VideoToolbox -framework OpenCL -I/usr/local/include -L/usr/local/lib/ -I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include -L/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/"</span>)</span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp iomodule/BiliMovieDownloader.cpp iomodule/BiliMovieDownloader.h videomodule/BiliMovieDumux.cpp videomodule/BiliMovieDumux.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(BiliBg <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg curl)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg bz2)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg z)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg iconv.<span class="number">2.4</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg /usr/local/lib/libavcodec.a)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg /usr/local/lib/libavformat.a)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg /usr/local/lib/libswscale.a)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg /usr/local/lib/libavdevice.a)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg /usr/local/lib/libavutil.a)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(BiliBg /usr/local/lib/libswresample.a)</span><br></pre></td></tr></table></figure>
<p>代码其实比较简单分成两个模块：</p>
<ul>
<li>io模块 负责请求，解析，下载</li>
<li>音视频分离模块 读取视频文件获取解码器，分离音视频</li>
</ul>
<p>代码地址：<a href="https://github.com/zq54zquan/bili-bmg" target="_blank" rel="noopener">这里</a></p>
<h3 id="TODO-有空的时候有可能做吧"><a href="#TODO-有空的时候有可能做吧" class="headerlink" title="TODO: (有空的时候有可能做吧)"></a>TODO: (有空的时候有可能做吧)</h3><ul>
<li>添加时间参数。分离特定时间的bgm </li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/07/CMake实战2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="麻虾儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左路不笑魔王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/CMake实战2/" itemprop="url">CMake实战2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-07T19:21:15+08:00">2018-03-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-编写CMakeLists文件"><a href="#4-编写CMakeLists文件" class="headerlink" title="4 编写CMakeLists文件"></a>4 编写CMakeLists文件</h1><p>这一章主要覆盖了为你的软件编写CMakeLists文件一些基础，我们将会学习到你在大多数项目中遇到的所有的基本命令和一些问题,也会学习下周末把现有的UNIX或者Windows项目转换到CMake上来，因为CMake能处理非常复杂的项目，所以大多数项目中你会发现这一章的内容完全够用啦，CMake是被CMakeLists文件驱动的，CMakeList文件决定一切，比如Cache中的值，需要被编译的文件。最后会讨论下怎么让CMakeLists文件健壮并且可维护，基础的语法和关键概念都已经在上边的章节说过了，这一章将张开这些概念并且引入一些新的东西</p>
<h2 id="4-1-CMake-语法"><a href="#4-1-CMake-语法" class="headerlink" title="4.1 CMake 语法"></a>4.1 CMake 语法</h2><p>CMakeLists文件遵守一个简单的语法规则(注释，命令，空白符)，注释是从一个<code>#</code>开始的知道行尾，命令是由命令名称，小括号，空白符分割的参数组成的，含有空白符的参数用双引号括起来，反斜线可以做转移符，后边的一些列子会帮你解决语法上困惑，你可能回想CMake为什么不用先用的语言的语法来实现，比如Python啥的，主要的母的是想让CMake不要依赖其他的东西来运行，要是依赖了这些语言的话，安装就会很大,也需要依赖特定版本的语言，我们自己干的话就没有性能和兼容问题啦</p>
<h2 id="4-2-基本命令"><a href="#4-2-基本命令" class="headerlink" title="4.2 基本命令"></a>4.2 基本命令</h2><p>上一章已经介绍了蛮多基础的基础命令了，这一章将会重新来看下并且要展开来讲下，第一个命令是顶层CMakeLists文件要包含的<code>PROJECT</code>命令，这个命令不仅可以给项目命名还能指定工程使用的语言他的语法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project (projectname [CXX] [C] [Java] [NONE])</span><br></pre></td></tr></table></figure>
<p>如果没有指定语言，CMake默认会支持C和C++，如果指定了NONE，CMake将会不包含任何语言支持，当CPP被支持的时候C的支持也会加载的</p>
<p>对于项目中每一个<code>project</code>命令,CMake会创建一个顶层的IDE的project文件，这个项目会包含CMakeLists文件中的所有Target，添加子目录需要使用<code>add_subdirectory</code>命令，如果<code>EXCLUDE_FROM_ALL</code>选项被用在<code>add_subdirectory</code>命令中的话，生产的项目将不会出现在顶层的Make文件或者IDE的项目文件中。这个功能在你想要让你的子目录的项目和你的主项目没啥关系的时候很有用,举个栗子，假设你的工程有很多例子项目,你可以使用这个功能来为你的例子生产编译文件，但是在正常的编译中不会包含例子目录</p>
<p><code>set</code>命令可能是用的最多的命令，他可以用来定义和修改变量和列表，和<code>set</code>相对的，<code>remove</code>和<code>separate_arguments</code>命令，<code>remove</code>命令可以用来从变量列表里边删除值，<code>separate_arguments</code>可以用来把一个单一的变量值用空白分割成一个列表</p>
<p><code>add_executable</code>和<code>add_library</code>命令是用来定义库和可执行文件的编译和源码的，加的源码可以包含头文件，反正基于makefile的generators是会简单的省略掉</p>
<h2 id="4-3-流控制"><a href="#4-3-流控制" class="headerlink" title="4.3 流控制"></a>4.3 流控制</h2><p>在很多方面写一个CMakeList文件就和写一段程序是一毛一样的，所以和其他的编程语言一样，CMake为咱提供了控制流结构：</p>
<ul>
<li>条件判断语句(例如:<code>if</code>等)</li>
<li>循环结构(例如:<code>foreach</code>和<code>while</code>等)</li>
<li>程序流程定义(例如<code>macro</code>和<code>function</code>等)</li>
</ul>
<p>首先我们看下<code>if</code>命令，在很多方面和在其他编程语言是一样的，计算表达式的值，根据结果运行命令的体内的代码或者运行可选的<code>else</code>中的代码。举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (FOO)</span><br><span class="line"># do something here</span><br><span class="line">else (FOO)</span><br><span class="line"># do something else</span><br><span class="line">endif(FOO)</span><br></pre></td></tr></table></figure>
<p>一个你可能注意到的不一样的地方就是<code>if</code>中的条件在<code>else</code>和<code>endif</code>中都会重复写一次，这个是可选的，在这本书里边你将看到两种风格的代码，你可以自己选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (FOO)</span><br><span class="line"># do something here </span><br><span class="line">else()</span><br><span class="line"># do something else</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p><code>if</code>命令有一些使用的限制，它不支持一些像<code>${FOO} &amp;&amp; ${BAR} || ${FUBAR}</code>这样的C类型的表达式，作为替代，它支持一些表达式的子集，大多数情况下，这些就够啦，<code>if</code>命令支持:</p>
<ul>
<li><p><strong><code>if(variable)</code></strong></p>
<p>  如果变量的值不是空，0，FALSE, OFF或者NOTFOUND</p>
</li>
<li><p><strong><code>if(NOT variable)</code></strong> </p>
<p>  如果变量的值是空，0， FALSE, OFF或者NOTFOUND</p>
</li>
<li><p><strong><code>if(variabl1 AND variable2)</code></strong>    </p>
<p>  变量同时为真，表达式为真</p>
</li>
<li><p><strong><code>if(varibale1 OR variable2)</code></strong> </p>
<p>  变量一个为真，表达式为真</p>
</li>
<li><p><strong><code>if(COMMAND command-name)</code></strong></p>
<p>  如果给定的命令名称是一个可调用的命令，表达式为真</p>
</li>
<li><p><strong><code>if(DEFINED variable)</code></strong></p>
<p>  如果变量被set过，不管这个值是多少，表达式为真</p>
</li>
<li><p><strong><code>if(EXISTS file-name)</code></strong></p>
</li>
<li><p><strong><code>if(EXISTS directory-name)</code></strong></p>
<p>  如果文件或者目录存在，表达式为真</p>
</li>
<li><p><strong><code>if(IS_DIRECTORY directory-name)</code></strong></p>
</li>
<li><p><strong><code>if(IS_ABSOLUTE name)</code></strong></p>
<p>  如果名称是一个目录或者一个绝对路径，表达式为真</p>
</li>
<li><p><strong><code>if(name1 IS_NEWER_THAN name2)</code></strong></p>
<p>  最后修改时间文件1比文件2更新，表达式为真</p>
</li>
<li><p><strong><code>if(variable MATCH regex)</code></strong></p>
</li>
<li><p><strong><code>if(string MATCH regex)</code></strong></p>
<p>  如果给定的字符串或者变量的值符合正则，表达式为真</p>
</li>
</ul>
<p><code>EQUAL</code>,<code>LESS</code>,和<code>GREATER</code>可以用作数值比较</p>
<p><code>STRLESS</code>,<code>STREQUAL</code>,和<code>STRGREATER</code> 可以用作字符字面值的比较</p>
<p><code>VERSION_LESS</code>,<code>VERSION_EQUAL</code>和<code>VERSION_GREATER</code>可以用来做像<code>major.[.minor[.patch.[.tweak]]]</code>这样的版本比较，像C/C++一样，这些表达式可以组合起来使用来创建更多复杂的比较，举个栗子，考虑下边的这些情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if ((1 LESS 2) AND (3 LESS 4))</span><br><span class="line">	message(&quot;sequence of numbers&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">if (1 AND 3 AND 4)</span><br><span class="line">	message(&quot;series of true values&quot;)</span><br><span class="line">endif(1 AND 3 AND 4)</span><br><span class="line"></span><br><span class="line">if (nor 0 AND 3 AND 4)</span><br><span class="line">	message (&quot;a flase value&quot;)</span><br><span class="line">endif(NOT 0 AND 4 AND 4)</span><br><span class="line"></span><br><span class="line">if (0 OR 3 AND 4)</span><br><span class="line">	message (&quot;or statements&quot;)</span><br><span class="line">endif (0 OR 3 AND 4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (EXISTS $&#123;PROJECT_SOURCE_DIR&#125;/help.txt AND COMMAND IF)</span><br><span class="line">	message(&quot;help text&quot;)</span><br><span class="line">endif （EXISTS $&#123;PROJECT_SOURCE_DIR/help.txt AND COMMAND IF&#125;）</span><br><span class="line"></span><br><span class="line">set (foobar 0)</span><br><span class="line">if (NOT DEFINED foobar)</span><br><span class="line">	message (&quot;foobar is not defined&quot;)</span><br><span class="line">endif (NOT DEFINED foobar)</span><br><span class="line"></span><br><span class="line">if (NOT DEFINED fooba)</span><br><span class="line">	message (&quot;fooba not defined&quot;)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>在复合的<code>if</code>语句中，有一个指定运算符的执行的顺序，在下边的表达式中，<code>NOT</code>会在<code>AND</code>之前运行，而不是相反的顺序，因此表达式的结果是<code>false</code>，打印的语句也不会执行，如果<code>AND</code>先运行的话，结果就是<code>true</code>了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (NOT 0 AND 0)</span><br><span class="line">	message (&quot;this line is nerver executed&quot;)</span><br><span class="line">endif (NOT 0 AND 0)</span><br></pre></td></tr></table></figure>
<p>CMake 定义了操作符的执行顺序，比如括号内的表达式先支持性，<code>EXISTS</code>,<code>COMMAND</code>,<code>DEFINED</code>和相似的前缀运算符先执行，然后是想<code>EQUAL</code>,<code>LESS</code>,<code>GREATER</code>,<code>STREQUAL</code>,<code>STRLESS</code>,<code>STRGREATER</code>和<code>MATCHS</code>运算符，之后运行<code>NOT</code>运算符，最后是<code>AND</code>和<code>OR</code>,哪些具有相同执行级别的运算符比如<code>AND</code>和<code>OR</code>将会从左到右执行，一旦所有的表达式都执行并得到整个表达式的结果，CMake将<code>ON</code>,<code>1</code>,<code>YES</code>,<code>TRUE</code>,<code>Y</code>当做<code>true</code>,将<code>OFF</code>,<code>0</code>,<code>NO</code>,<code>FALSE</code>,<code>N</code>,<code>NOTFOUND</code>,<code>*-NOTFOUND</code>,<code>IGNORE</code>当做false，计算的值的大小写不敏感的，所有<code>true</code>,<code>True</code>和<code>TRUE</code>是相同的</p>
<p>咱们现在再来看下另外一种控制流命令，<code>foreach</code>,<code>while</code>,<code>macro</code>和<code>function</code>命令是减少你CMakeLists文件大小并保证可维护性的的最好的命令，<code>foreach</code>命令可以让你在一个列表中重复运行一组CMake命令，我们看看下边VTK中的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">foreach (tfile </span><br><span class="line">		TestAnisotropicDiffusion2D</span><br><span class="line">		TestButterworthLowPass</span><br><span class="line">		TestButterworthHighPass</span><br><span class="line">		TestCityBlockDistance</span><br><span class="line">		TestConvolve</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">add_test ($&#123;tfile&#125;-image $&#123;VTK_EXECUTABLE&#125;</span><br><span class="line">		$&#123;VTK_SOURCE_DIR&#125;/Tests/rtImageTest.tcl</span><br><span class="line">		$&#123;VTK_SOURCE_DIR&#125;/Tests/$&#123;tfile&#125;.tcl</span><br><span class="line">		-D $&#123;VTK_DATA_ROOT&#125;</span><br><span class="line">		-V Baseline/Imaging/$&#123;tfile&#125;.png</span><br><span class="line">		-A $&#123;VTK_SOURCE_DIR&#125;/Wrapping/Tcl</span><br><span class="line">		)</span><br><span class="line">endforeach (tfile)</span><br></pre></td></tr></table></figure>
<p><code>foreach</code>的第一个参数是在循环中使用的变量名。剩余的参数是用来做循环的列表的值，在栗子中的<code>foreach</code>循环只是一个CMake命令<code>add_test</code>,在<code>foreach</code>的循环体内部任何时候都可以使用循环变量(<code>tfile</code>)来指代列表中在当前迭代中的元素，在第一次迭代中，${tfile}将会被<code>TestAnisotropicDiffusion2D</code>替换，下一个迭代<code>${tfile}</code>将会被<code>TestButterworthLowPass</code>替代,<code>foreach</code>将会继续循环知道所有参数都被处理完为止</p>
<p>值得一提的是，<code>foreach</code>可以嵌套使用，循环变量在任意表达式之前被替换成列表中的值，这意味着，在<code>foreach</code>的循环体中可以使用循环变量来创建新的变量名，下边的代码循环变量<code>tfile</code>被展开，然后和<code>_TEST_RESULT</code>组合起新的变量，新变量的名字被展开和并当场<code>if</code>的条件表达式来运算:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($&#123;$&#123;tfile&#125;_TEST_RESULT&#125; MATCHES FAILED)</span><br><span class="line">	message (&quot;Test $&#123;tfile&#125; failed&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p><strong> 原文中<code>if</code>表达式的参数是<code>${${tfile}}_TEST_RESULT} MATCHES FAILED</code>,应该是有问题的 </strong></p>
<p><code>while</code>命令提供了一个基于条件判断的循环，条件表达式的格式和<code>if</code>是一样的，考虑下边CTest中使用的栗子，注意CTest在内部更新了<code>CTEST_ELAPSED_TIME</code>的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">################################################################################</span><br><span class="line">#  run paraview and ctest dashboards for 6 hours</span><br><span class="line"># </span><br><span class="line">while ($&#123;CTEST_ELAPSED_TIME&#125; LESS 36000)</span><br><span class="line">	set (START_TIME $&#123;CTEST_ELAPSED_TIME&#125;)</span><br><span class="line">	ctest_run_script (&quot;dash1_ParaView_vs71continuous.cmake&quot;)</span><br><span class="line">	ctest_run_script (&quot;dash1_cmake_vs71continuous.cmake&quot;)</span><br><span class="line">endwhile()</span><br></pre></td></tr></table></figure>
<p><code>foreach</code>和<code>while</code>命令可以让你处理重复的任务，<code>macro</code>和<code>function</code>命令支持把散落在CMakeLists文件中的重复的任务打包。一旦他们被定义，任何在定义之后CMakeLists文件都可以使用他们</p>
<p>CMake中的function和C/C++中的function很相似，你可以传递参数，在方法内部参数变成了变量，就像其他的标准变量<code>ARGC</code>,<code>ARGV</code>,<code>ARGN</code>和<code>ARGV0</code>,<code>ARGV1</code>等等，在function内部，你就在一个新的变量作用域中了，有点像你使用<code>add_subdirectorty</code>命令进入了一个新的子目录使用新的变量作用域一样，所有定义的变量在方法调用中还是被定义的，但是任何在对这些变量的改变或者新的变量都只存在于方法内部，当方法返回之后，这些都会消失不见，更简单点说，当你调用一个方法是，一个新的变量作用域被push到栈顶，当你从方法返回时，作用域被pop掉</p>
<p> function 的第一参数是方法名称，剩下的参数都是function的正式参数啦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function (DetermineTime _time) </span><br><span class="line"># pass the result up to whatever invoked this</span><br><span class="line">	set ($&#123;_time&#125; &quot;1:23:45&quot; PARENT_SCOPE)</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line">DetermineTime( current_time ) </span><br><span class="line">if (DEFINED current_time)</span><br><span class="line">	message(STATUS &quot;the time is now: $&#123;current_time&#125;&quot;)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>注意这个栗子中的<code>_time</code>被用作返回值的名称，<code>set</code>命令使用<code>_time</code>的<strong>值</strong>。这个栗子中就是<code>current_time</code>,最后<code>set</code>命令使用<code>PARENT_SCOPE</code>选项来设置变量的值到父作用域</p>
<p><code>macro</code>的定义和调用在默写方面是和<code>function</code>是一样的，主要的不同点在于，<code>macro</code>没有push和pop新的变量作用域，并且参数不是作为变量，而是作为字符串在运行前被替换的，这些很像C/C++里边的方法和宏的区别。</p>
<p>第一个参数作为<code>macro</code>的名字，后边的作为参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define a simple macro</span><br><span class="line"></span><br><span class="line">macro (assert TEST COMMENT)</span><br><span class="line">	if (NOT $&#123;TEST&#125;)</span><br><span class="line">		message (&quot;Assertion failed: $&#123;COMMENT&#125;&quot;)</span><br><span class="line">	endif(NOT $&#123;TEST&#125;)</span><br><span class="line">endmacro(assert)</span><br><span class="line"></span><br><span class="line">#use the macro</span><br><span class="line">find_library (FOO_LIB foo /usr/local/lib)</span><br><span class="line">assert ($&#123;FOO_LIB&#125; &quot;Unable to find library foo&quot;)</span><br></pre></td></tr></table></figure>
<p>上边的简单例子中创建了一个叫做<code>assert</code>的宏，这个宏使用了两个参数，第一个是用于测试的值，第二个是如果测试失败打印的字符串，<code>macro</code>的宏体内是一个简单的<code>if</code>命令和一个<code>message</code>命令。<code>macro</code>用一个<code>endmacro</code>来作为结束，<code>macro</code>可以像一个普通的命令一样被调用，在上边的例子中，如果<code>FOO_LIB</code>没找到，就会显示一条信息来表示错误情况</p>
<p><code>macro</code>命令同样支持定义使用参数列表的宏，当你想要用可变参数或者多签名(???)时会很有用。可变参数可以使用<code>ARGC</code>,<code>ARGV0</code>,<code>ARGV1</code>等来引用，<code>ARGV0</code>表示宏的第一个参数，<code>ARGV1</code>代表下一个，以此类推，你甚至可以使用最少的正式参数和可变参数.下边举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># define a macro that takes at least two arguments</span><br><span class="line"># (thr formal arguments) plus an optional third argument</span><br><span class="line"></span><br><span class="line">macro (assert TEST COMMENT)</span><br><span class="line">	if (NOT $&#123;TEST&#125;)</span><br><span class="line">		message (&quot;Assertion failed :$&#123;COMMENT&#125;&quot;)</span><br><span class="line">		# if called with three arguments then also write the </span><br><span class="line">		# message to a file specified as the third argument</span><br><span class="line">		if ($&#123;ARGC&#125; MATCHES 3) </span><br><span class="line">			file (APPEND $&#123;ARGV2&#125; &quot;Assertion failed: $&#123;COMMENT&#125;&quot;)</span><br><span class="line">		endif ($&#123;ARGC&#125; MATCHES 3)</span><br><span class="line">	endif (NOT $&#123;TEST&#125;)</span><br><span class="line">endmacro (assert)</span><br><span class="line"></span><br><span class="line">#use the macro</span><br><span class="line">find_library (FOO_LIB foo /usr/local/lib)</span><br><span class="line">assert ($&#123;FOO_LIB&#125; &quot;Unable to find library foo&quot;)</span><br></pre></td></tr></table></figure>
<p>CMake有连个命令用于打断执行流，<code>break</code>命令可以打断<code>foreach</code>和<code>while</code>循环的正常执行，<code>return</code>命令将从方法或者listfile的正常结束之前返回</p>
<p>在这个栗子中，<code>TEST</code>和<code>COMMENT</code>是两个必备的参数，像这个例子中一样这些必备参数可以使用名称来引用,也可以使用<code>ARGV0</code>,<code>ARGV1</code>,如果你想要把参数当成列表来使用，你可以使用<code>ARGV</code>和<code>ARGN</code>变量，<code>ARGV</code>(相对于<code>ARGV0</code>,<code>ARGV1</code>等等)是一个宏的全参数列表，<code>ARGN</code>是正式参数之后的参数列表，在宏体内，你可以使用<code>foreach</code>命令来遍历<code>ARGV</code>或者<code>ARGN</code></p>
<h2 id="4-4-正则表达式"><a href="#4-4-正则表达式" class="headerlink" title="4.4 正则表达式"></a>4.4 正则表达式</h2><p>有些CMake命令比如<code>if</code>和<code>string</code>会使用正则或者使用正则作为一个参数，在简单的模式下，一个正则是一系列的字符用于匹配搜索确切的字符，不过，很多时候我们不知道确切的字符串是什么，或者只知道字符串的开头和结尾，因为有好几种不同的方式来指定正则，CMake的标准制动如下:</p>
<p>正则可以使用标准的字母数字组合来指定，并使用下边的这些元字符：</p>
<p><code>^</code> 匹配以一行或者一个字符串的开始</p>
<p><code>$</code> 匹配一行或一个字符串的结尾</p>
<p><code>.</code> 匹配一个处理换行外的任意字符</p>
<p><code>[]</code> 匹配中间的任意字符</p>
<p><code>[^ ]</code> 匹配不在符号中间的任意字符</p>
<p><code>[ - ]</code> 匹配范围</p>
<p><code>*</code> 匹配前一个模式0次或多次</p>
<p><code>+</code> 匹配前一个模式1次货多次</p>
<p><code>?</code> 匹配前一个模式0次或1次</p>
<p><code>()</code> 保存匹配的表达式，后边可以再用</p>
<p><code>(|)</code> 匹配|左边或者右边的模式</p>
<p>注意上边的这些元字符可以在单一的模式中使用不止一次用来创建一个复杂的搜索模式，举个栗子，<code>[^ab1-9]</code>匹配任意的不是以a,b或者数字开头的字符序列,下边的栗子可以帮助我们了解正则的用法:</p>
<ul>
<li><p><code>^hello</code>只匹配哪些以<code>hello</code>开头的字符串，他可以匹配<code>&quot;hello there&quot;</code>, 但是不匹配<code>&quot;hi,\n hello there&quot;</code>.</p>
</li>
<li><p><code>long$</code> 匹配 <code>long</code>结尾的字符串，他匹配<code>so long</code>,不匹配<code>long ago</code></p>
</li>
<li><p><code>t..t..g</code> 匹配一个<code>t</code>然后两个字符，另一个<code>t</code>和连个字符，最后是一个<code>g</code>,可以匹配<code>testing</code>或者<code>test again</code>, 但是不能匹配<code>toasting</code>.</p>
</li>
<li><p><code>[1-9ab]</code>匹配1-9数字和a,b, 他可以匹配<code>hello 1</code>或者<code>begin</code> 但是不匹配<code>no-match</code></p>
</li>
<li><p><code>[^1-9ab]</code>匹配任意的非1-9的数字和非a,b的字母，他<strong>不</strong>匹配<code>1ab2</code>和<code>b2345a</code>,但是可以匹配<code>no-match</code></p>
</li>
<li><p><code>br*</code>匹配以一个<code>b</code>开头跟着0个或多个<code>r</code>并且以空格结尾的字符串，他可以匹配<code>brrrrr</code>和<code>b</code>,但是不能匹配<code>brrh</code></p>
</li>
<li><p><code>br+</code>匹配以<code>b</code>开头跟着一个或多个<code>r</code>并且以空格结尾的字符串，他可以匹配<code>brrrrr</code>和<code>br</code>，但是不匹配<code>b</code>或者<code>brrh</code></p>
</li>
<li><p><code>br?</code>匹配以一个<code>b</code>开头跟随0个或者1个<code>r</code>并且以空格结尾的字符串，他可以匹配<code>br</code>和<code>b</code>，但是不匹配<code>brrrrr</code>或者<code>brrh</code></p>
</li>
<li><p><code>(..p)b</code>匹配以<code>pb</code>结尾，任意两个字符在第一次遇到<code>p</code>的时候，可以在<code>rep drepaqrepb</code>搜索到<code>repb</code>, <code>(..p)a</code>可以在<code>repa drepb qrepb</code>中搜索到<code>repa qrepb</code></p>
</li>
<li><p><code>d(..p)</code>匹配那些以d开头，以p结尾并且中间包含两个字符，并且这两个字符与第一次遇到p之前的是相同的，他可以在<code>rep drepa qrepb</code>中搜索到<code>drepa qrepb</code></p>
</li>
</ul>
<h2 id="4-5-检查CMake的版本"><a href="#4-5-检查CMake的版本" class="headerlink" title="4.5 检查CMake的版本"></a>4.5 检查CMake的版本</h2><p>CMake是一个不断进化的程序，新的功能和命令随着新版本不停的发布，这就会导致一个问题，你可能想要使用一个在最新版本中的命令，但是在旧版本中却不支持，有好几种方法可以处理这种问题，一种选择就是使用<code>if</code>命令来检查命令是否存在，举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># test if the command exists</span><br><span class="line"></span><br><span class="line">if (COMMAND some_new_command) </span><br><span class="line">	#use the command</span><br><span class="line">	some_new_command (ARGS...)</span><br><span class="line">endif(COMMAND some_new_command)</span><br></pre></td></tr></table></figure>
<p>上边的方法大多数情况下都是适用的，但是如果你想要得到更多的信息，你可以使用<code>CMAKE_VERSION</code>变量来测试当前正在运行的CMake的版本，举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># look for newer version of CMake</span><br><span class="line"></span><br><span class="line">if ($&#123;CMAKE_VERSION&#125; VERSION_GREATER 1.6.1)</span><br><span class="line">	#do something special here</span><br><span class="line">endif ()</span><br></pre></td></tr></table></figure>
<p>当编写CMakeLists文件的时候你可以指定不支持旧版本的CMake。要使用这个功能只需要把下边的命令放在CMakeLists文件的最上边就行啦:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.2)</span><br></pre></td></tr></table></figure>
<p>这一行指定了，要在你的项目上运行CMake，版本必须大于等于2.2, 如果在老版本上运行，会显示一条错误信息来提示你需要的CMake的最小版本号</p>
<p>最后，有些情况下，新版本会废弃掉一些命令，这个时候你可以使用CMake policies 下边的<a href="#4.7">4.7</a>会讲到</p>
<h2 id="4-6-使用模块"><a href="#4-6-使用模块" class="headerlink" title="4.6 使用模块"></a>4.6 使用模块</h2><p>CMake支持代码复用，CMakeLists可以使用可复用的模块。CMake对于这些复用的代码称作section，可以在CMake安装的模块子目录中找到. 模块就是简单的把CMake命令放在一个文件里边。举个栗子，之后可以使用<code>#include</code>命令引入进来，举个栗子，下边的命令将会引入<code>FindTCL</code>模块，并添加Tcl库到FOO目标中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include (FindTCL)</span><br><span class="line">target_link_libraries (FOO $&#123;TCL_LIBRARY&#125;)</span><br></pre></td></tr></table></figure></p>
<p>模块的位置可以使用绝对路径指定，或者可以让CMake自己去寻找，CMake会在<code>CMAKE_MODULE_PATH</code>指定的地址中寻找模块，如果没有找到，会在CMake的模块目录中寻找。这样项目可以覆盖CMake提供的模块来适配自己的需求，模块可以分成下边的几种主要的类型:</p>
<ul>
<li><strong>Find Modules</strong><br>  这些模块决定了软件的组件比如头文件或者库的位置</li>
<li><strong>System Introspection Modules</strong><br>  这些模块测试系统的一些属性，比如float的大小，ANSI C++ 流的支持等等</li>
<li><strong>Utility Modules</strong><br>  这些模块提供了额外的一些功能，比如一个CMake项目基于另外一个，和一些其他的方便的路由</li>
</ul>
<p>现在让我们来详细的看下这三种模块,CMake引入了大量的Find Modules，他们的目的是定位软件的组件，比如头文件或者库文件，如果不能找到，他们会提供一个cache件让用户可以设置需要的属性，考虑下边的用于寻找PNG库的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"># find the native PNG includes and library</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># this module defines</span><br><span class="line"># PNG_INCLUDE_DIR ,用于寻找 png.h 等</span><br><span class="line"># PNG_LIBRARIES 用于链接的PNG库</span><br><span class="line"># PNG_DEFINITIONS 你应该在编译引入png库的代码文件之前调用add_definitions ($&#123;PNG_DEFINITIONS&#125;) </span><br><span class="line"># PNG_FOUND 如果是false，不要使用PNG</span><br><span class="line"></span><br><span class="line"># 被定义了,不过一般情况下不用</span><br><span class="line"># PNG_LIBRARY 哪里寻找PNG Library</span><br><span class="line"></span><br><span class="line"># None of the above will be defined unless zlib can be found</span><br><span class="line"></span><br><span class="line"># PNG depends on Zlib</span><br><span class="line">include (FindZLib.cmake)</span><br><span class="line">if (ZLIB_FOUND)</span><br><span class="line">	find_path (PNG_PNG_INCLUDE_DIR png.h /usr/local/include /usr/include)</span><br><span class="line">	find_library (PNG_LIBRARY png /usr/lib /usr/local/lib )</span><br><span class="line">	if (PNG_LIBRARY) </span><br><span class="line">		if (PNG_PNG_INCLUDE_DIR)</span><br><span class="line">			# png.h includes zlib.h .Sigh</span><br><span class="line">			set (PNG_INCLUDE_DIR $&#123;PNG_PNG_INCLUDE_DIR&#125; $&#123;ZLIB_INCLUDE_DIR&#125;)</span><br><span class="line">			set (PNG_LIBRARIES $&#123;PNG_LIBRARY&#125; $&#123;ZLIB_LIBRARY&#125;)</span><br><span class="line">			set (PNG_FOUND &quot;YES&quot;)</span><br><span class="line">			if (CYGWIN)</span><br><span class="line">				if (BUILD_SHARED_LIBS)</span><br><span class="line">					# NO need to define PNG_USE_DLL here, because it&apos;s default for cygwin</span><br><span class="line">				else (BUILD_SAHRED_LIBS)</span><br><span class="line">					set (PNG_DEFINITIONS -DPNG_STATIC)</span><br><span class="line">				endif(BUILD_SHARED_LIBS) </span><br><span class="line">			endif (CYGWIN)</span><br><span class="line">		endif()</span><br><span class="line">	endif</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p>
<p>头部的文档已经说明了模块的功能和模块定义的变量,他引入了另一个模块–FindZLIB模块，他会确认Zlib库是不是已经安装了，再然后，如果ZLib被找到了，<code>find_path</code>命令用来定位PNG的头文件，第一个用于保存结果，第二个参数是需要找的头文件的名字，剩余的参数是用于寻找这个头文件的路径，如果在系统目录中没有找到，变量会被设置成<code>PNG_PNG_INCLUDE_DIR-NOTFOUND</code>,用户可以修改这个值</p>
<p>注意搜搜PNG库的路径可以包含硬编码的目录，注册条目，使用其他CMake变量创建出来不的目录，下一个命令<code>find_library</code>寻找PNG库真正位置。这个命令会检查来寻找正确的库名，比如Linux上在名称前添加<code>lib</code>,在名称后边添加<code>.so</code></p>
<p>在find运行之后，设置了一些CMake变量，使用FindPNG模块的开发者可以使用这些变量(比如include路径，库的名称)，最后<code>PNG_FOUND</code>设置正确让使用的开发者知道PNG库被正确的找到了</p>
<p>这个结构在CMake寻找模块中中是正常操作，通常都很短，但是在默写情况下，比如<code>FindOpenGL</code>可能有几页长，他们通常是独立于其他模块的，但是没有使用其他模块的限制</p>
<p>系统自省模块可以提供关于目标平台或者编译器的信息，模块可以提供关于目标平台或者编译器的信息, 很多这种模块都有一个以<code>Test</code>或者<code>Check</code>的前缀，比如<code>TestBigEndian</code>和<code>CheckTypeSize</code>，很多系统自省模块实际上是尝试去编译代码来判断结果是否正确，这些情况下，源码文件的名称和模块经常是一样的，只是加上一个.c或者.cxx的后缀，在第五章会详细说说系统自省模块</p>
<p>CMake包含一些工具模块帮助你更简单的使用CMake，CMakeExportBuildSettings和CMakeImportBuildSettings提供了帮助检验两个不同的C++项目是否使用看了相同的编译器和参数的工具，CMakePrintSystemInfomation模块打印出在debug程序是有用的关键的CMake设置信息</p>
<h3 id="SWIG中使用CMake"><a href="#SWIG中使用CMake" class="headerlink" title="SWIG中使用CMake"></a>SWIG中使用CMake</h3><p>一个很好的使用模块的栗子就是看看怎样使用SWIG把你的C/C++代码包装成另外一种语言.SWIG(Simplified Wrapper and Interface Generator)就是一个创建胶水语言（不翻了），CMake可以使用<code>find_package</code>命令支持SWIG.尽管SWIG可以做CMake中作为客户话的命令使用。不过SWIG包提供了一些宏来是创建SWIG项目相对简单点，要使用这些宏，首先使用<code>find_package</code>命令SWIG的名称做为参数，然后你需要引入</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/07/CMake实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="麻虾儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="左路不笑魔王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/CMake实战/" itemprop="url">CMake实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-07T18:32:34+08:00">2018-03-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2-3-cmkae基本语法和语法"><a href="#2-3-cmkae基本语法和语法" class="headerlink" title="2.3 cmkae基本语法和语法"></a>2.3 cmkae基本语法和语法</h2><p>使用cmake很简单,build过程被创建的CMakeLists.txt文件所控制,包含在子目录中的CMakelists.txt文件，CMakeLists文件应该描述了项目的结构,基本的命令的形式如下: </p>
<p><code>command (args ...)</code></p>
<p>args 是用空白符分开的参数列表(参数如果包含空格，就用双引号包含下),CMake是大小写不敏感的(2.2之后)<br>所以你可以使用command或者COMMAND</p>
<p>CMake支持简单的变量比如字符串或者字符串列表，使用${变量}来引用, 多个参数可以使用<code>set</code>命令打包到列表中去，所有的其他命令会展开用空白符分隔来展开列表</p>
<p>举个栗子 <img src="http://img.mp.itc.cn/upload/20170320/81a3c11642104d87b0a2e33b2eaafdd3.jpeg" alt="举个栗子"> </p>
<p><code>set (Foo a b)</code> 命令的结果是将a,b,c包进Foo变量，所以如果传递<code>Foo</code>到另外一个命令<code>COMMAND(${Foo})</code>和<code>COMMAND(a b c)</code>是一样的</p>
<p>如果你想要将列表传递给命令作为一个单独的参数，只需要简单的用双引号包括以下就行</p>
<p>再举个栗子 <img src="http://img.mp.itc.cn/upload/20170320/81a3c11642104d87b0a2e33b2eaafdd3.jpeg" alt="再举个栗子"> </p>
<p><code>COMMAND(&quot;${Foo}&quot;)</code> 和 <code>COMMAND(&quot;a b c&quot;)</code>是一样的效果</p>
<p>系统环境变量和Windows的注册变量(注册表啥的吧，不懂:&lt;)在CMake中都可以访问，要访问系统环境变量使用<code>$ENV{变量}</code>语法，CMake还可以在很多不同的命令中使用<code>[HKEY_CURRENT_URSER\\Software\\path1\\path2;key]</code>引用注册变量,这些路径是注册树和key</p>
<h2 id="2-4-CMake-Hello-World"><a href="#2-4-CMake-Hello-World" class="headerlink" title="2.4 CMake Hello World"></a>2.4 CMake Hello World</h2><p>咱们来看个简单的吧:), 为了从源码中编译出一个可执行文件，CMake需要一个CMakeLists.txt文件，文件中需要包含两行:</p>
<p><code>project (Hello)
add_executable (Hello Hello.c)</code></p>
<p>为了编译出Hello可执行文件，咱们运行CMake来生成Makefiles或者巨硬的项目文件。</p>
<ul>
<li><code>project</code>命令标识了结果的工作空间应该叫什么</li>
<li><code>add_executable</code>命令向编译程序添加了一个可执行的目标</li>
</ul>
<p>如果你的项目需要不是特别多的源文件，只需要简单的修改下add_executable就好啦:</p>
<p><code>add_executable(Hello Hello.c File2.c File3.c File4.c)</code></p>
<p><code>add_executable</code>只是CMake众多命令中的一件。咱们来看看一个更不清真的栗子:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(<span class="number">2.6</span>)</span><br><span class="line"><span class="keyword">project</span> (HELLO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (HELLO_SRCS Hello.c File2.c File3.c)</span><br><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">	<span class="keyword">set</span> (HELLO_SRCS <span class="variable">$&#123;HELLO_SRCS&#125;</span> WinSupport.c) </span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">	<span class="keyword">set</span> (HELLO_SRCS <span class="variable">$&#123;HELLO_SRCS&#125;</span> UnixSupport.c) </span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (HELLO <span class="variable">$&#123;HELLO_SRCS&#125;</span>)</span><br><span class="line"><span class="comment">#look for thr Tcl library</span></span><br><span class="line"><span class="keyword">find_library</span> (TCL_LIBRARY NAMES tcl tcl84 tcl83 tcl82 tcl80 PATHS /usr/lib /usr/local/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TCL_LIBRARY) </span><br><span class="line">	target_link_library(Hello <span class="variable">$&#123;TCL_LIBRARY&#125;</span>) </span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure>
<p>这个栗子里边使用<code>set</code>命令来打包参数列表，使用<code>if</code>命令来添加各自平台的支持文件，最后使用了<code>add_executable</code>命令来编译可执行文件，<code>find_library</code>命令搜索TCL_LIBRARY使用了不同的名称和不同的路径，使用一个<code>if</code>命令来判断TCL_LIBRARY是否找到，如果找到了就把他link到可执行文件的target中，注意<code>#</code>作为一个注释来使用，从<code>#</code>到行尾都是注释部分</p>
<h2 id="2-5-如何运行CMake"><a href="#2-5-如何运行CMake" class="headerlink" title="2.5 如何运行CMake"></a>2.5 如何运行CMake</h2><p>只要你系统里边装了CMake，使用它来编译项目很简单，CMake用两个主要的目录来编译项目:源码目录和二进制目录。源码目录里边包含源码和CMakeLists.txt文件。二进制目录就是放可执行文件，库，目标文件这些东西的，一般来说，CMake不会在源码目录里边写东西，只在二进制目录里边干活，如果你想让CMake在源码目录里边写东西的话:&lt;(一般不要这么做吧，不明白什么时候需要这么干)，就把源码目录和二进制目录设置成一样的就妥了这个就是–in-source-build。相对的就是out-source-build。</p>
<p>CMake在所有平台上两种方式都是资瓷的。就是说你用out-source-build的时候你可以简单地删除掉所有编译期间生产的文件。拥有不同的编译路径和源码路径让资瓷对同一份代码的多个编译很简单，这个功能在你想要用不同的编译选项编译同一份代码的时候很有用。CMake还有一个QT的GUI(蛤，我为什么要用这个，反正我不用，我就不翻了)</p>
<h4 id="在控制台运行CMake"><a href="#在控制台运行CMake" class="headerlink" title="在控制台运行CMake"></a>在控制台运行CMake</h4><p>在命令行上，CMake可以当成一个交互的问答式的会话或者是一个无交互的程序。加上<code>-i</code>参数就可以启动交互模式，交互模式下Cmake将会为每一个参数询问你。CMake将会提供有效的默认值。CMake将问完所有的问题然后停止</p>
<p>使用无交互模式编译项目在不需要参数或者很少参数的时候很简单。对于大型的项目像VTK,使用gui或者cmake -i比较推荐。</p>
<p>使用CMake的无交互模式，首先cd到你想要放二进制的目录,in-source-build的话就直接运行cmake,加上-D来传递编译选项。out-source-build的话同样的操作，只是需要你添加上源文件的目录作为cmake的参数。然后使用<code>make</code>命令来编译你的项目，有些项目会包含 install 目标，你可以使用<code>make install</code>来安装他们</p>
<h4 id="指定编译器"><a href="#指定编译器" class="headerlink" title="指定编译器"></a>指定编译器</h4><p>有时候在你的操作系统里边可能包好不止一个编译器或者编译器不在标准的路径下边，这个时候你告诉CMake你想要用的编译器在什么地方。有三种方法可以实现这个功能: </p>
<ul>
<li>generator可以指定编译器</li>
<li>设置环境变量参数</li>
<li>设置一个缓存实例</li>
</ul>
<p>默写generator可以绑定在特定的编译器，例如宇宙第一IDE的generator就是绑定到VS的编译器的。基于Makefile的generator会尝试一个常用的编译器列表。一般这个列表可以在这些文件中找到:</p>
<blockquote>
<p>Modules/CMakeDeterminCCompiler.cmake<br>Modules/CMakeDeterminCxxCompiler.cmake</p>
</blockquote>
<p>这个列表可以被环境变量覆盖掉。</p>
<ul>
<li>CC 环境变量用来指定C编译器</li>
<li>CXX 用来指定c++编译器</li>
</ul>
<p>你可以使用——DCMake_CXX_COMPILER=cl直接在命令行上指定编译器。如果不设置这个的话，CMake会依次选择下边的这些编译器:</p>
<blockquote>
<p>c++ g++ CC aCC cl bcc xlC</p>
</blockquote>
<p>CMake开始运行并且选好编译器之后,你可以修改缓存选项CMAKE_CXX_COMPILER和CMAKE_C_COMPILER修改选择的编译器，不过这种做法是不推荐的，这么做的问题主要是项目可能是你的配置可能已经运行了一些基于编译器的测试来判断一些支持特性。修改了编译器之后可能会导致一些不正确的结果。如果你必须修改编译器。重在一个新的空的二进制目录中进行。编译器的flags和链接器同意可以使用环境变量来修改。<br>设置LDFLAFGS将会为link flag初始化一个缓存值,同样的CXXFLAGS和CFLAGS将会初始化CMAKE_CXX_FLAGS和CMAKE_C_FLAGS</p>
<h4 id="依赖分析"><a href="#依赖分析" class="headerlink" title="依赖分析"></a>依赖分析</h4><p>CMake拥有一个强大的内置C/C++依赖分析能力,CMake还支持部分的Java和Fortran依赖分析，因为IDE支持和维护了依赖信息，CMake对这些编译系统放弃了这部分功能，但是，Makefiels是不了解怎么样去计算和维护依赖信息的，对于这些系统，CMake为C/C++/Fortran自动计算依赖信息，CMake自动生成和维护依赖信息，这些都是自动完成的，如果一个项目是用CMake配置的，用户主需要运行Make，CMake会帮你完成剩余的工作，对于多处理器系统CMake完全支持并行编译</p>
<p>尽管用户不需要知道CMake是如何工作的，不过看一下项目的依赖信息文件也没啥坏处:),为每一个target创建的依赖文件保存在这四个文件中：</p>
<ul>
<li>depend.make</li>
<li>flags.make</li>
<li>build.make </li>
<li>DependInfo.cmake</li>
</ul>
<blockquote>
<p>depend.make保存了目录中的所有目标文件的所有的依赖信息<br>flags.make包含了编译的flags</p>
</blockquote>
<p>这两个文件如果改变了，源码就会被重新编译</p>
<blockquote>
<p>DependInfo.cmakes是保持更新信息更新，并且包含了项目中包括哪些文件和这些文件使用的语言<br>最后编译依赖的规则保存在build.make中，如果依赖不是过期了，所有的依赖需要重新计算来保持信息永远是最新的</p>
</blockquote>
<h2 id="2-6-编辑-CMakeLists-文件"><a href="#2-6-编辑-CMakeLists-文件" class="headerlink" title="2.6 编辑 CMakeLists 文件"></a>2.6 编辑 CMakeLists 文件</h2><p>CMakeLists文件可以用几乎任意的文本编辑器来编辑,有些编辑器比如Notepad++内置了语法高亮和缩进支持，神的编辑器和编辑器之神也内置了语法和缩进支持</p>
<p>这段没啥营养啦，反正我用vim…</p>
<h2 id="2-7-为CMake设置初始值"><a href="#2-7-为CMake设置初始值" class="headerlink" title="2.7 为CMake设置初始值"></a>2.7 为CMake设置初始值</h2><p>尽管CMake在交互模式下运行的很好，有时你也可能在没有GUI的时候设置下缓存条目，这种情况是很常见的当设置nightly dashboard(不明白这边)<a href="unknow0"></a>或者是你将创建很多编译树使用相同的cahce值，在这些情况下，CMake缓存可以以两种方式被初始化，第一种方式是使用CMake命令行下<code>-DCACHE_VAR:TYPE=VALUE</code>传递cache值</p>
<p>再举个栗子 <img src="http://img.mp.itc.cn/upload/20170320/81a3c11642104d87b0a2e33b2eaafdd3.jpeg" alt="再举个栗子"> </p>
<p>考虑下边的nightly dashboard脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/tcsh</span><br><span class="line">cd $&#123;HOME&#125;</span><br><span class="line">#wipe out the old binary tree and then create it again</span><br><span class="line">rm -rf Foo-Linux</span><br><span class="line">mkdir Foo-Linux</span><br><span class="line">cd Foo-Linux</span><br><span class="line">#run cmake to setup the cache</span><br><span class="line">cmake -DBUILD_TESTING:BOOL=ON &lt;etc...&gt; ../Foo</span><br><span class="line">#generate the dashboard</span><br><span class="line">ctest -D Nightly</span><br></pre></td></tr></table></figure>
<p>同样的方法可以用在windows的批处理文件上</p>
<p>第二种方式是创建一个文件用来被CMake -C选项来加载。这种情况下取代-D这种方式的是使用一个文件来使用CMake解析，这个文件的语法就是标准的CMakeLists语法，通常来说就是一系列的<code>set</code>命令像这样的：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Build the vtkHybrid kit always</span></span><br><span class="line"><span class="keyword">set</span> (VTK_USE_HYBRID <span class="keyword">ON</span> CACHE BOOL <span class="string">"doc"</span> FORCE)</span><br></pre></td></tr></table></figure>
<p>还有一种方法是你想要设置一个变量然后隐藏他，用户不会改变这个值，用下边的命令可以实现</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Build the vtkHybrid kit always</span></span><br><span class="line"><span class="keyword">set</span> (VTK_USE_HYBRID <span class="keyword">ON</span> CACHE BOOL <span class="string">"doc"</span> FORCE)</span><br><span class="line"><span class="keyword">mark_as_advanced</span> (VTK_USE_HYBRID)</span><br></pre></td></tr></table></figure>
<p>你可能会想直接编辑cache文件，或者去“初始化”一个项目通过给他一个初始的cache文件的方式，这有可能跑不出来，或者在以后出现问题，首先，CMake cahe的语法是修改的东西，第二，cache 文件包含了完整路径。</p>
<h2 id="2-8-编译你的项目"><a href="#2-8-编译你的项目" class="headerlink" title="2.8 编译你的项目"></a>2.8 编译你的项目</h2><p>运行完了CMake之后就可以准备编译了。如果你的编译系统是基于make的，你就cd到你的二进制目录然后运行make就行啦，如果是IDE的话就加载生产的项目文件，然后你按你平时的操作来就行了</p>
<p>另外一种选择就是在命令行中使用CMake的编译选项，这个选项就是一个便利的工具让你在命令行编译你的项目<br>运行下<code>cmake -build</code>你就知道怎么用了。</p>
<h4 id="不清楚的地方"><a href="#不清楚的地方" class="headerlink" title="[不清楚的地方]"></a>[不清楚的地方]</h4><ul>
<li><a href="#unknow0">nightly dashboard</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">麻虾儿</p>
              <p class="site-description motion-element" itemprop="description">老特拉福德我的家</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zq54zquan" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:zq54zquan@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">麻虾儿</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.5</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.5"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.5"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.5"></script>



  



	





  





  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

</body>
</html>
