<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SDWebImage源码分析]]></title>
    <url>%2F2018%2F03%2F30%2FSDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SDWebImage使我们平时开发中用的非常多的一个突破加载缓存库. 主要组件根据源码的group我们可以看出项目大概的组件: 下载模块，缓存模块，解码模块，工具类，category 首先我们看看下载模块。按道理下载是不依赖上层的实现的 Downloader首先看下SDWebImageDownloaderOperation类，这个类继承NSOperation,提供了多线程能力。看下初始化方法，其实就是写普通的赋值操作。 类中定义了- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock方法。实现也简单，就是在callback的字典中保存这两个回调的copy。- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key 这个方法可以看下: 12345678- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key &#123; LOCK(self.callbacksLock); NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy]; UNLOCK(self.callbacksLock); // We need to remove [NSNull null] because there might not always be a progress block for each callback [callbacks removeObjectIdenticalTo:[NSNull null]]; return [callbacks copy]; // strip mutability here&#125; 其中这里对NSArray调用KVC,结果是啥呢? 文档看下知道啦 Return an array containing the results of invoking -valueForKey: on each of the receiver’s elements. The returned array will contain NSNull elements for each instance of -valueForKey: returning nil. 其实就是对其中的每个元素做KVC获得一个新的数组，对于其中返回nil的返回NSNull之后再清掉NSnull就得到一个callbacks数组中的所有元素的对应的含有key的值的列表了,然后是cancel:方法，就是在callbacks数组中删除回调，之后如果要是为0了，就调用cancel方法 之后可以看到主方法start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899- (void)start &#123; @synchronized (self) &#123; if (self.isCancelled) &#123; self.finished = YES; [self reset]; return; &#125;#if SD_UIKIT Class UIApplicationClass = NSClassFromString(@"UIApplication"); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123; __weak __typeof__ (self) wself = self; UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123; __strong __typeof (wself) sself = wself; if (sself) &#123; [sself cancel]; [app endBackgroundTask:sself.backgroundTaskId]; sself.backgroundTaskId = UIBackgroundTaskInvalid; &#125; &#125;]; &#125;#endif NSURLSession *session = self.unownedSession; if (!session) &#123; NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; sessionConfig.timeoutIntervalForRequest = 15; /** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */ session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; self.ownedSession = session; &#125; if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123; // Grab the cached data for later check NSURLCache *URLCache = session.configuration.URLCache; if (!URLCache) &#123; URLCache = [NSURLCache sharedURLCache]; &#125; NSCachedURLResponse *cachedResponse; // NSURLCache's `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483 @synchronized (URLCache) &#123; cachedResponse = [URLCache cachedResponseForRequest:self.request]; &#125; if (cachedResponse) &#123; self.cachedData = cachedResponse.data; &#125; &#125; self.dataTask = [session dataTaskWithRequest:self.request]; self.executing = YES; &#125; if (self.dataTask) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wunguarded-availability" if ([self.dataTask respondsToSelector:@selector(setPriority:)]) &#123; if (self.options &amp; SDWebImageDownloaderHighPriority) &#123; self.dataTask.priority = NSURLSessionTaskPriorityHigh; &#125; else if (self.options &amp; SDWebImageDownloaderLowPriority) &#123; self.dataTask.priority = NSURLSessionTaskPriorityLow; &#125; &#125;#pragma clang diagnostic pop [self.dataTask resume]; for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; progressBlock(0, NSURLResponseUnknownLength, self.request.URL); &#125; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf]; &#125;); &#125; else &#123; [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:@&#123;NSLocalizedDescriptionKey : @"Task can't be initialized"&#125;]]; [self done]; return; &#125;#if SD_UIKIT Class UIApplicationClass = NSClassFromString(@"UIApplication"); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123; UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)]; [app endBackgroundTask:self.backgroundTaskId]; self.backgroundTaskId = UIBackgroundTaskInvalid; &#125;#endif&#125; 首先是查看cancelled属性，如果是true,直接复位返回。然后看是否支持后台任务并且设置了需要后台任务支持的就添加后台任务超时处理。然后是获取session和URLCache中缓存的数据，再根据传入的request新建dataTask，设置优先级，如果设置了progresscallback就调用一次progress是0的调用并发送通知,之后是取消刚刚创建的后台任务 然后来看下网络请求的回调方法: 1234- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler 这边的逻辑也比较简单，主要是对一个304的特殊处理，如果上面没有获取到cachedata会把304当成cancel处理 1- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data 这个方法的也没啥复杂的就是计算下进度，然后在看看是否使用渐进式的解码方式来解码图片数据(解码以后再说吧，不知道想不想看。。。。) 1- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error 失败的处理很简单我们就别看了，我们看看成功的处理首先获取成功的回调block，如果获取到的数据和urlcache数据是一致的，并且使用了只是用cache的配置的话，就会调用空图片和finish为true的回调其他情况下会在单独解码线程queue中做从imageData转换出图片这边可以用ImageIO来获取图片的方向，并创建出key,并根据url是否包含@2x这种字符串,设置图片的scale之后根据是否需要解码图片来解码图片。 再来看下SDWebImageDownloader类。首先看到的是一个initialize方法，在其中添加了下载开始和停止的通知处理，然后我们可以看到这个类应该是一个单例有一个shareDownloader的方法，之后是两个初始化方法。看下123456789101112131415161718192021222324252627282930313233343536373839404142- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123; // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return nil; &#125; LOCK(self.operationsLock); SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url]; if (!operation) &#123; operation = createCallback(); __weak typeof(self) wself = self; operation.completionBlock = ^&#123; __strong typeof(wself) sself = wself; if (!sself) &#123; return; &#125; LOCK(sself.operationsLock); [sself.URLOperations removeObjectForKey:url]; UNLOCK(sself.operationsLock); &#125;; [self.URLOperations setObject:operation forKey:url]; // Add operation to operation queue only after all configuration done according to Apple's doc. // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock. [self.downloadQueue addOperation:operation]; &#125; UNLOCK(self.operationsLock); id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; SDWebImageDownloadToken *token = [SDWebImageDownloadToken new]; token.downloadOperation = operation; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; return token;&#125; 这边重要的方法其实就是这个createCallback方法来创建这个operation的方法。来看下这个创建的block的实现: 123456789101112131415161718192021222324252627282930313233343536373839404142__strong __typeof (wself) sself = wself;NSTimeInterval timeoutInterval = sself.downloadTimeout;if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0;&#125;// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwiseNSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);request.HTTPShouldUsePipelining = YES;if (sself.headersFilter) &#123; request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);&#125;else &#123; request.allHTTPHeaderFields = [sself allHTTPHeaderFields];&#125;SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];operation.shouldDecompressImages = sself.shouldDecompressImages;if (sself.urlCredential) &#123; operation.credential = sself.urlCredential;&#125; else if (sself.username &amp;&amp; sself.password) &#123; operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];&#125;if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh;&#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow;&#125;if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation's dependency [sself.lastAddedOperation addDependency:operation]; sself.lastAddedOperation = operation;&#125;return operation; 这边可以看到创建operation时把self.session传进去，这样就理解了这边所有的代理方法都走到operation代理方法的原因了，因为operation礼拜呢的session就是我们这边传入的session,其他的都是一些参数的传递，没有什么好说的 下载的部分大概就这么多吧。== 未完待续 ==]]></content>
      <categories>
        <category>技术</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aspects源码解析]]></title>
    <url>%2F2018%2F03%2F19%2FAspects%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Aspects是开源Objectiv-C面向切面编程的实现AOP简介基于切面编程不是Objective-C创造出来的编程范式，在J2EE中经常使用的Spring框架就使用了这种编程范式 It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a “pointcut” specification, such as “log all function calls when the function’s name begins with ‘set’”. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code, core to the functionality. AOP forms a basis for aspect-oriented software development. 就是在不改动原有代码的情况下来添加新的行为.在 某一个切点 上修改。比如添加log这种事情，可以在不弄乱业务代码的情况下添加一些非关键的代码。 AOP源码解析AOP之前的验证Aspects可以实现在OC的方法的某些切入点中添加行为。展开源码看，只有两个文件Aspects.h和Aspects.m两个文件，实现文件也只有1000行不到的代码量，可以说是很小的一个库了从最头文件开始看，可以发现对外暴露的可用的接口就是一个NSObject的类别，提供了两个方法。一个是在类上添加AOP特性的方法，还有一个是在特定的实例上添加AOP特性的方法。在实现文件中可以看到这两个方法都是调用了aspect_add的一个静态函数。 1234567891011121314151617181920static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123; NSCParameterAssert(self); NSCParameterAssert(selector); NSCParameterAssert(block); __block AspectIdentifier *identifier = nil; aspect_performLocked(^&#123; if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123; AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error]; if (identifier) &#123; [aspectContainer addAspect:identifier withOptions:options]; // Modify the class to allow message interception. aspect_prepareClassAndHookSelector(self, selector, error); &#125; &#125; &#125;); return identifier;&#125; 关于断言可以看先NSHipster的这篇文章,参看源码可以出aspect_performLocked方法的实现很简单，是在一个spinlock中运行block，可以看到这个lock是一个静态变量，这就保证了这个方法在同一个时刻只能被调用一次 再来看下block中的内容.if条件的代码调用了aspect_isSelectorAllowedAndTrack方法。追踪代码进入待这个方法中看看它究竟做了什么。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081static BOOL aspect_isSelectorAllowedAndTrack(NSObject *self, SEL selector, AspectOptions options, NSError **error) &#123; static NSSet *disallowedSelectorList; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; disallowedSelectorList = [NSSet setWithObjects:@"retain", @"release", @"autorelease", @"forwardInvocation:", nil]; &#125;); // Check against the blacklist. NSString *selectorName = NSStringFromSelector(selector); if ([disallowedSelectorList containsObject:selectorName]) &#123; NSString *errorDescription = [NSString stringWithFormat:@"Selector %@ is blacklisted.", selectorName]; AspectError(AspectErrorSelectorBlacklisted, errorDescription); return NO; &#125; // Additional checks. AspectOptions position = options&amp;AspectPositionFilter; if ([selectorName isEqualToString:@"dealloc"] &amp;&amp; position != AspectPositionBefore) &#123; NSString *errorDesc = @"AspectPositionBefore is the only valid position when hooking dealloc."; AspectError(AspectErrorSelectorDeallocPosition, errorDesc); return NO; &#125; if (![self respondsToSelector:selector] &amp;&amp; ![self.class instancesRespondToSelector:selector]) &#123; NSString *errorDesc = [NSString stringWithFormat:@"Unable to find selector -[%@ %@].", NSStringFromClass(self.class), selectorName]; AspectError(AspectErrorDoesNotRespondToSelector, errorDesc); return NO; &#125; // Search for the current class and the class hierarchy IF we are modifying a class object if (class_isMetaClass(object_getClass(self))) &#123; Class klass = [self class]; NSMutableDictionary *swizzledClassesDict = aspect_getSwizzledClassesDict(); Class currentClass = [self class]; AspectTracker *tracker = swizzledClassesDict[currentClass]; if ([tracker subclassHasHookedSelectorName:selectorName]) &#123; NSSet *subclassTracker = [tracker subclassTrackersHookingSelectorName:selectorName]; NSSet *subclassNames = [subclassTracker valueForKey:@"trackedClassName"]; NSString *errorDescription = [NSString stringWithFormat:@"Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy.", selectorName, subclassNames]; AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription); return NO; &#125; do &#123; tracker = swizzledClassesDict[currentClass]; if ([tracker.selectorNames containsObject:selectorName]) &#123; if (klass == currentClass) &#123; // Already modified and topmost! return YES; &#125; NSString *errorDescription = [NSString stringWithFormat:@"Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.", selectorName, NSStringFromClass(currentClass)]; AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription); return NO; &#125; &#125; while ((currentClass = class_getSuperclass(currentClass))); // Add the selector as being mo. currentClass = klass; AspectTracker *subclassTracker = nil; do &#123; tracker = swizzledClassesDict[currentClass]; if (!tracker) &#123; tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass]; swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker; &#125; if (subclassTracker) &#123; [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName]; &#125; else &#123; [tracker.selectorNames addObject:selectorName]; &#125; // All superclasses get marked as having a subclass that is modified. subclassTracker = tracker; &#125;while ((currentClass = class_getSuperclass(currentClass))); &#125; else &#123; return YES; &#125; return YES;&#125; 首先验证selector是不是包含在一组不允许AOP的方法组里，这边看到了一个forwardInvocation方法，(⊙v⊙)嗯。。特殊的一个然后验证这个类的class是不是metaclass。上边也说到了是有两个接口来分别为类和类的实例分别来做AOP,因为调用的是同一个静态方法，这个地方就需要区分开来分别判断。在类的AOP中首先验证当前类的这个selector是否被hook过。然后在验证是否在类的超类层级上被hook过，这些只要是被hook过的，都不能进行第二次hook了。 最后会为类型添加一个AspectTracker的类型实例存放在静态的字典中,同时也会为超类的的selectorNamesToSubclassTrackers添加这个tracker。如果是当前的类的话就是在selectorNames添加这个selector的名字然后上边的方法返回yes之后，调用aspect_getContainerForObject方法。在这个方法中创建一个新的selector。并用这个selector作为key来帮定了一个AspectsContainer实例。然后创建一个AspectIdentifier实例:可以看到其中调用了aspect_blockMethodSignature来获得一个NSMethodSignature实例。在这方法中会用到一个结构体: 1234567891011121314151617typedef struct _AspectBlock &#123; __unused Class isa; AspectBlockFlags flags; __unused int reserved; void (__unused *invoke)(struct _AspectBlock *block, ...); struct &#123; unsigned long int reserved; unsigned long int size; // requires AspectBlockFlagsHasCopyDisposeHelpers void (*copy)(void *dst, const void *src); void (*dispose)(const void *); // requires AspectBlockFlagsHasSignature const char *signature; const char *layout; &#125; *descriptor; // imported variables&#125; *AspectBlockRef; 看到这个结构体好像有点熟悉的样子,我们写个demo看下LLDB上的block的显示: 这样一看这个struct好像是block的原型呀！那我们就来看下block真正的样子吧！ 在llvm的源码中可以找到这个文件 1234567891011121314151617181920212223struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);&#125;;struct Block_layout &#123; void *isa; int flags; int reserved; void (*invoke)(void *, ...);&#125;//只是这边的descriptor中有两个常量`char *`,不过我们也看到了这两个变量是在最后放着的，不会影响前边的变量的访问的，不过如果要做到容器里边然后做迭代器的话应该是有问题的。这个不影响转换了成员变量的访问。//回到代码中,验证block的flags,做按位&amp;操作查看.上边的图上可以看到flags值是1342177280，做位操作是符合的。enum &#123; BLOCK_REFCOUNT_MASK = (0xffff), BLOCK_NEEDS_FREE = (1 &lt;&lt; 24), BLOCK_HAS_COPY_DISPOSE = (1 &lt;&lt; 25), BLOCK_HAS_CTOR = (1 &lt;&lt; 26), /* Helpers have C++ code. */ BLOCK_IS_GC = (1 &lt;&lt; 27), BLOCK_IS_GLOBAL = (1 &lt;&lt; 28), BLOCK_HAS_DESCRIPTOR = (1 &lt;&lt; 29)&#125;; 然后是增加desc指针的位置。我们这边就是加上两个long int的长度，这个时候就是copy和despose函数指针的位置。然后是如果flags有copy和despose方法的话还要再加两个指针的长度，到达signature指针的位置，然后查看signature是否为空。最后返回methodsignature。 不过这边有些地方不太明白 123456789101112131415161718struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself, int b) &#123;&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; 这边是我转换了一个普通的block的代码，实在是找不出这个signature是放在什么神奇的地方了 还有一份clang的文档显示这个block的struct定义是正确的。http://clang.llvm.org/docs/Block-ABI-Apple.html 这一块其实分析下来非常依赖llvm源码中的代码的数据结构定义。这边我们还是不能确认llvm中descriptor之后是什么，按照代码的定义来看来copy和dispose这两个函数都是不一定在这个位置的。现在怀疑可能是真实编译出来的代码在desc的后边还会有什么东西。这个实在是没法分析出来。 关于signature相关cstring的相关介绍可以参考官方文档，这边我们已经把一个cstring转换成了NSMethodSignature了就可以使用这个类的方法了。回到代码流程中，调用aspect_isCompatibleBlockSignature方法来验证signature判断是否参数个数合法，并且第一个参数必须是一个类实例,之后是分别判断各个参数的类型是否一致。只有出现不一致就返回错误之后新建一个AspectIdentifier类型的实例返回，成功的话在selector对应的container中添加这个identifer。 Hook过程之后是准备hook的方法aspect_prepareClassAndHookSelector.可以看到这个方法会调用一个关键的aspect_hookClass方法。 123456789101112131415161718192021222324252627282930313233343536373839static Class aspect_hookClass(NSObject *self, NSError **error) &#123; NSCParameterAssert(self); Class statedClass = self.class; Class baseClass = object_getClass(self); NSString *className = NSStringFromClass(baseClass); // Already subclassed if ([className hasSuffix:AspectsSubclassSuffix]) &#123; return baseClass; // We swizzle a class object, not a single object. &#125;else if (class_isMetaClass(baseClass)) &#123; return aspect_swizzleClassInPlace((Class)self); // Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place. &#125;else if (statedClass != baseClass) &#123; return aspect_swizzleClassInPlace(baseClass); &#125; // Default case. Create dynamic subclass. const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; Class subclass = objc_getClass(subclassName); if (subclass == nil) &#123; subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) &#123; NSString *errrorDesc = [NSString stringWithFormat:@"objc_allocateClassPair failed to allocate class %s.", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; aspect_swizzleForwardInvocation(subclass); aspect_hookedGetClass(subclass, statedClass); aspect_hookedGetClass(object_getClass(subclass), statedClass); objc_registerClassPair(subclass); &#125; object_setClass(self, subclass); return subclass;&#125; 这里边调用了self.class和object_getClass(self)这两个方法有什么区别呢？class方法的注释是 The class object for the receiver’s class. object_getClass方法的注释是: The class object of which object is an instance, or Nil if object is nil. 好像看不出啥呀。这种问题肯定有人遇到过吧，咱们看下Stack Overflow这个答案的回答中有一句: The reason is that the class of a Class object is the same class, but the object_getClass of a Class is the meta class (the class of the class). This makes sense because a Class is an instance of the meta class, and according to documentation object_getClass returns “The class object of which object is an instance”. 我们其实可以把object_getClas想成是获取到了不论是类或者实例真正的类型的方法。class方法对于实例变量就是class方法返回的东西(我们在后边会看到可以设置这个返回值)现在我们起码知道对于类类型的参数返回的结果肯定是不一样的，class返回类型本身，object_getClass返回的是metaclass。然后我们就可以看明白这几个判断条件了首先看类名是不是包含了我们定义好的固定前缀，如果是的话直接返回这个类如果不是看下是不是metaclass。如果是的话跑下aspect_swizzleClassInPlace方法如果不是metaclass。并且class和object_getClass的返回值不一样的话，说明这个类被KVO了。同样的运行aspect_swizzleClassInPlace方法如果这些都不符合，说明这个是一个普通的实例，我们就创建出一个基于baseclass 的子类。使用固定的前缀。然后我们看到调用aspect_swizzleForwardInvocation方法和aspect_hookedGetClass方法.最后是调用object_setClass方法，这个方法就是改变实例的isa指针.我们知道isa指针中存放了ivarlist，methodlist这些东西，修改了这个isa其实就算是修改了这个实例的整个实现。 我们再回头来看下aspect_swizzleClassInPlace方法，这个方法比较简单，用一个静态set保存了被swizzle的类名同样的关键还是调用aspect_swizzleForwardInvocation方法再来看下aspect_hookedGetClass方法,我们看到就是改变了类的class方法实现，这就清楚了，这样改变之后新的类的class方法不会返回新类的Class。而是依然使用旧的类型Class。这样这个就是对上层无感知的一个类了 接下来看下aspect_swizzleForwardInvocation这个方法的实现: 123456789static void aspect_swizzleForwardInvocation(Class klass) &#123; NSCParameterAssert(klass); // If there is no method, replace will act like class_addMethod. IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, "v@:@"); if (originalImplementation) &#123; class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, "v@:@"); &#125; AspectLog(@"Aspects: %@ is now aspect aware.", NSStringFromClass(klass));&#125; 这边也能看出是一个简单的swizzle方法。只是这个被swizzle掉的方法比较特殊，就是我们上边说的那个特殊的一个forwardInvocation.这个方法的实现被替换成了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123; NSCParameterAssert(self); NSCParameterAssert(invocation); SEL originalSelector = invocation.selector; SEL aliasSelector = aspect_aliasForSelector(invocation.selector); invocation.selector = aliasSelector; AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector); AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector); AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation]; NSArray *aspectsToRemove = nil; // Before hooks. aspect_invoke(classContainer.beforeAspects, info); aspect_invoke(objectContainer.beforeAspects, info); // Instead hooks. BOOL respondsToAlias = YES; if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123; aspect_invoke(classContainer.insteadAspects, info); aspect_invoke(objectContainer.insteadAspects, info); &#125;else &#123; Class klass = object_getClass(invocation.target); do &#123; if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123; [invocation invoke]; break; &#125; &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass))); &#125; // After hooks. aspect_invoke(classContainer.afterAspects, info); aspect_invoke(objectContainer.afterAspects, info); // If no hooks are installed, call original implementation (usually to throw an exception) if (!respondsToAlias) &#123; invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); if ([self respondsToSelector:originalForwardInvocationSEL]) &#123; ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); &#125;else &#123; [self doesNotRecognizeSelector:invocation.selector]; &#125; &#125; // Remove any hooks that are queued for deregistration. [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];&#125; 首先是修改了invocation的selector。获取改名之后的selector对应的container，之后是运行aspect_invoke(classContainer.beforeAspects, info)这个方法会分别调用列表中的各个元素的- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info方法。 1234567891011121314151617181920212223242526272829303132333435363738- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123; NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature]; NSInvocation *originalInvocation = info.originalInvocation; NSUInteger numberOfArguments = self.blockSignature.numberOfArguments; // Be extra paranoid. We already check that on hook registration. if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123; AspectLogError(@"Block has too many arguments. Not calling %@", info); return NO; &#125; // The `self` of the block will be the AspectInfo. Optional. if (numberOfArguments &gt; 1) &#123; [blockInvocation setArgument:&amp;info atIndex:1]; &#125; void *argBuf = NULL; for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123; const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx]; NSUInteger argSize; NSGetSizeAndAlignment(type, &amp;argSize, NULL); if (!(argBuf = reallocf(argBuf, argSize))) &#123; AspectLogError(@"Failed to allocate memory for block invocation."); return NO; &#125; [originalInvocation getArgument:argBuf atIndex:idx]; [blockInvocation setArgument:argBuf atIndex:idx]; &#125; [blockInvocation invokeWithTarget:self.block]; if (argBuf != NULL) &#123; free(argBuf); &#125; return YES;&#125; 在这个方法中会将invocation的第二个参数设置为info的指针。之后是依次在原先的invocation中获取参数类型和参数大小，之后再获取参数本身，之后设置到新的invocation中去。之后是调用这个invocation，将这个invocation的target设置为block本身。这样就可以把这段代码想象成是这样的代码片段了 新建一个invocation。签名和以前的block的签名一样 获取旧invocation的参数，并设置到新的invocation中， 以旧的block作为argment0.info作为argment1. 调用invocation 这边其实和上边是那个获取签名的地方是一样的，我还是搞不清楚这个第一个参数类型为什么是info 之后回到aspect_prepareClassAndHookSelector方法，可以看到就方法被新的改名的方法替换掉.旧方法被替换成了_objc_msgForward的实现。所以我们对原方法的调用就会走到_objc_msgForward, 之后走到forwardInvocation方法中。我们看下这篇YY大神的博客 结合NSObject文档可以知道，_objc_msgForward消息转发做了如下几件事：1.调用resolveInstanceMethod:方法，允许用户在此时为该Class动态添加实现。如果有实现了，则调用并返回。如果仍没实现，继续下面的动作。 2.调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接转发给它。如果返回了nil，继续下面的动作。 3.调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。 4.调用forwardInvocation:方法，将地3步获取到的方法签名包装成Invocation传入，如何处理就在这里面了。 上面这4个方法均是模板方法，开发者可以override，由runtime来调用。最常见的实现消息转发，就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。 前边两个步骤都是继续，走到第三步，我们可以看到，我们对实例使用原方法的selector调用methodSignatureForSelector,还是可以返回正确的signature的，所以走到第四步就会走到我们自定义的forwordInvocation方法中了。 == (完) ==]]></content>
      <categories>
        <category>技术</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Aspects</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LKImageView源码分析2]]></title>
    <url>%2F2018%2F03%2F15%2FLKImageView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%2F</url>
    <content type="text"><![CDATA[接着上一次的LKImageManager中的combineRequest:方法继续分析。可以看到这边使用了一个在初始化时使用的NSOperationQueue,在初始化方法中我们可以看到，这个queue是一个maxConcurrentOperationCount是1的queue,可以把他当成一个同步的queue来看了。在combineRequest:方法中我们看到这个queue使用了一个类别方法- (void)lk_addOperation:(NSOperation *)op request:(LKImageRequest *)request，看看源码十分简单，通过reques的同步与否来看是直接运行opeation还是加入到queue中去等待执行。operation是通过blockOperationWithBlock方法创建的。可以看看其中的实现:123456789101112131415161718192021222324252627282930313233343536if (requestLV0.isCanceled)&#123; atomic_fetch_sub(&amp;LKImageRunningRequestCount, 1); atomic_fetch_add(&amp;LKImageCancelRequestCount, 1); requestLV0.isFinished = YES; requestLV0.error = [LKImageError errorWithCode:LKImageErrorCodeCancel]; [requestLV0 managerCallback:nil isFromSyncCache:NO]; [requestLV0.imageManagerCancelOperation cancel]; requestLV0.imageManagerCancelOperation = nil; return;&#125;LKImageLogVerbose([NSString stringWithFormat:@"LKImageManagerProcessRequest:%@", requestLV0]);LKImageRequest *requestLV1 = nil;requestLV0.error = nil;if (!requestLV0.synchronized)&#123; requestLV1 = [self.requestDic objectForKey:requestLV0.identifier];&#125;if (requestLV1)&#123; LKImageLogVerbose([NSString stringWithFormat:@"ManagerRequestCombine:%@", requestLV1]); [requestLV1 addChildRequest:requestLV0]; return;&#125;else&#123; requestLV1 = [requestLV0 createSuperRequest]; if (!requestLV0.synchronized) &#123; LKImageLogVerbose([NSString stringWithFormat:@"ManagerRequestCreate:%@", requestLV1]); [self.requestDic setObject:requestLV1 forKey:requestLV1.identifier]; &#125;&#125;[self loadRequest:requestLV1]; 先看到的是参看isCanceled属性。如果是cancel的话就使用无锁系统函数来更新请求个数。并且把reques的状态更新。然后是- (void)managerCallback:(UIImage *)image isFromSyncCache:(BOOL)isFromSyncCache方法,这个方法我们上一篇说过就是调用request和requestList的回调方法,然后清除imageManagerCancelOperation然后看下LKImageRequest的addChildRequest:方法.基本上是同步下请求的属性到superRequest中，并且在requestList中添加。createSuper方法调用了copy这个方法值得留一下: 123456789101112131415161718192021222324252627282930313233343536373839- (id)copy&#123; LKImageRequest *request = [[[self class] alloc] init]; Class cls = [self class]; while (cls != [NSObject class]) &#123; unsigned int numberOfIvars = 0; Ivar *ivars = class_copyIvarList(cls, &amp;numberOfIvars); for (const Ivar *p = ivars; p &lt; ivars + numberOfIvars; p++) &#123; Ivar const ivar = *p; NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)]; if (key == nil) &#123; continue; &#125; if ([key length] == 0) &#123; continue; &#125; id value = [self valueForKey:key]; @try &#123; [request setValue:value forKey:key]; &#125; @catch (NSException *exception) &#123; &#125; &#125; if (ivars) &#123; free(ivars); &#125; cls = class_getSuperclass(cls); &#125; return request;&#125; 可以看到这个方法是遍历本身的class的超类。并且获取对应的ivar数据，这边给我提供了一个新的设置值的思路，就是通过获取ivar的name来创建出一个key，然后通过key使用kvc来做值的设置，一般情况下，我们都是使用object_setIvar(&lt;#id _Nullable obj#&gt;, &lt;#Ivar _Nonnull ivar#&gt;, &lt;#id _Nullable value#&gt;)这个方法来做ivar的赋值的，一般情况下对于非类类型的ivar需要做方法的类型转换。这个就不能像上边那样做到使用kvc这种通用的方法来实现，这种应该还是是只适应于像LKImageRequest这种没有私有的值包含ivar，不包含setter的方法的类型KVO。 之后会调用loadRequest:(LKImageRequest *)requestV1. 这边会用到一个大一点的类LKImageLoaderManager这几段代码看下来之后基本可以确定对于对同一个资源的请求，如果是异步请求，会缓存一个request下来，之后对于同一个资源的请求会做一个相当于进程组的东西出来，这个第一次被copy的相当与进程组的头，然后我们再联系前边的requestList属性的callback的调用。就可以看出对于东一个资源只会有一个请求，但是会有多个回调回来，这些回调就是存储在requestList中了，在完成之后遍历的调用。这个做法很有想法。 LKImageLoaderManager这个类中的- (void)imageWithRequest:(LKImageRequest *)requestLV1 callback:(LKImageLoaderCallback)callback方法和LKImageManager有些类似。同样是用来生产一个相当于进程组的东西来实现对同一个资源的多次请求的合并。在这个方法中同样会把一个LKImageLoaderProtocol的实例赋值给request,从这个类的初始化函数中，可以看出需要两个数组，一个LKImageLoader数组和一个LKImageDecoder数组,我们这边的request的loader就是在这个数组中找出一个合法的可以用的loader来作为属性保存。在loadRequest方法中,可以看到使用loader的semaphore来控制异步的请求，在请求取消或者请求结束之后会把request的loaderOperation赋值为nil。 LKImageLoader这个类本身可以看做一个虚基类，包含了一个NSOperationQueue,一个gcdqueue(同步)和一个gcd信号。 我们看到在configuration中包含了5中源码中提供的LKImageLoader的子类 我们简单的看下： LKImageBundleLoader- (void)imageWithRequest:(LKImageRequest *)request callback:(LKImageImageCallback)callback方法被复写。代码很简单，就是看request的URL是不是含有后缀，有的话就在主bundle里边找到对应的图片，没有后缀的会就直接imageNamed加载。主要应该是用来应对imageNamed加载不到的类型的图片,JPEG什么的然后就是调用callback了LKImageLocalFileLoader,LKImagePhotoKitLoader和LKImageMemoryImageLoader实现也比较简单，就不展开说了 LKImageNetworkFileLoader- (void)dataWithRequest:(LKImageRequest *)request callback:(LKImageDataCallback)callback 可以看到首先是在本地文件目录中寻找图片，不是本地图片使用URLSession来做网络请求。这边其实也不复杂，使用两个容器类型的实例来存储一个封装了NSURLSessionTask的类型。这么做的原因是有些东西用URLSessionTask是保持不住的。 CallBack –&gt; Decoder请求结束之后的回到中首先调用requestDidFinished把异步请求的dictionary中的数据清除。对于请求获取到的是image或者data数据分别做两种不同处理。对于Data的数据是调用LKImageDecoderManager的- (void)decodeImageFromData:(NSData *)data request:(LKImageRequest *)request complete:(LKImageDecoderCallback)complete方法、之后就是调用系统解码来解码图片，其中包含了是对GIF的处理。 LKImageProcessorManager在请求的callback调用回到imageManager之后会运行processorManager的代码，这边可以看出这几个manager的架构师差不多的，都是可扩展的，使用每一个LKImageProcessor去处理特效。之后还是会回到CacheManager中去缓存图片 == (完) ==]]></content>
      <categories>
        <category>技术</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>LKImageKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LKImageView源码分析]]></title>
    <url>%2F2018%2F03%2F13%2FLKImageView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LKImageKit是腾讯开源的基于OC的图片管理类的集合框架 在项目主页上的README中说明包含了3个模块: 加载模块 解码模块 缓存模块 我们采用从上到下的分析方式来解析它的代码，首先是最常用的类LKImageView 从几个init方法中可以看出来，启动一个LKImageView的代码都需要调用setup方法，在这个方法中其实就是初始化了一个用于展示的imageView实例,并对于一些属性设置了default值，比较简单并且还新建了一个LKImageManager实例，这个会在后边解释既然添加了subview,就看下layoutSubviews方法,看到调用了layoutAndLoad方法。这个方法会根据图片的size,scale在加上屏幕的scale和控件的大小以及contentMode计算出imageView的frame.比如: LKImageScaleModeNone 为居中显示图片，使用图片本身的大小 (不会变形) LKImageScaleModeScaleToFill 直接使用控件大小平铺 (可能变形) LKImageScaleModeAspectFit LKImageScaleModeAspectFill都是不会变形的缩放,差距只是在控件和图片本身的宽高比大小比较时选取的基准的不同 之后还会调用加载图片的代码，在后边会展开代码来解析. 下一步来看下加载本地图片的时候是怎么做：LKImageViewoverwrite了setImage方法: 12345678910111213- (void)setImage:(UIImage *)image&#123; self.loadingImageRequest = nil; self.failureImageRequest = nil; if (image) &#123; self.request = [LKImageImageRequest requestWithImage:image]; &#125; else &#123; self.request = nil; &#125;&#125; 这边也算是比较好理解的了。如果传入的图片不是nil，就会新建一个LKImageImageRequest实例并且set给自身的属性 然后再看下LKImageImageRequest这个类的实现，基类是LKImageRequest. 12345678+ (instancetype)requestWithImage:(UIImage *)image key:(NSString *)key&#123; LKImageImageRequest *request = [[LKImageImageRequest alloc] init]; request.image = image; request.keyForLoader = [NSString stringWithFormat:@"%p",image]; request.synchronized = YES; return request;&#125; 基本可以确定对于本地图片是同步加载的。不过这个方法里边这key就有点尴尬啦，完全没有用到:(, keyForLoader取的key是这个image的内存地址。在研究这个Request的代码之前我们先回过来看下LKImageView的setRequest方法 12345678910111213141516171819- (void)setRequest:(LKImageRequest *)request&#123; request.internalProcessorList = self.processorList; if (![_request isEqual:request] || _request.error) &#123; [self.imageManager cancelRequest:_request]; _request = request; &#125; if (!_request) &#123; [self internalSetImage:nil withRequest:nil]; &#125; [self setNeedsLayout]; if (!self.delayLoadingImage) &#123; [self layoutIfNeeded]; &#125;&#125; internalProcessorList这个数组是图片的处理模块的processor，就是加特效 代码中看到的就是blur和gray两个东西 然后看如果原先的request和设置的新的requset不是相同的或者原先的请求出现error的话就会走到imageManager cacheRequest的代码。这块先略过然后就会发现代码调用了setNeedsLayout和layoutIfNeeded方法，这个时候就会回到上边说的layoutSubviews方法和layoutAndLoad了，我们上面没有展开这个代码，只是说了frame的变化。现在详细展开之后: 1234567891011121314151617181920212223242526272829303132333435363738- (void)layoutAndLoad&#123; [self layoutImageView]; if (self.request.state == LKImageRequestStateFinish &amp;&amp;!CGSizeEqualToSize(self.oldSize, self.size) &amp;&amp;(!self.presentationImage||self.presentationImage.lk_isScaled)) &#123; [self.request reset]; &#125; if (self.request &amp;&amp; self.request.state == LKImageRequestStateInit) &#123; self.oldSize = self.size; __weak LKImageView *wself = self; if (!self.request.synchronized) &#123; if (self.loadingImageRequest) &#123; [self dealWithRequest:self.loadingImageRequest]; [self.imageManager sendRequest:self.loadingImageRequest completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache]; &#125;]; &#125; &#125; [self dealWithRequest:self.request]; [self.imageManager sendRequest:self.request completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache]; &#125;]; &#125;&#125; 第一步是上面说过的计算imageView的frame的代码,剩余的代码是对request的操作,假设我们第一次调用这个方法也就是说这个request刚刚被alloc出来，所以这个时候state==LKImageRequestStateInit，所以走不到reset，其实reset相当于情况状态: 1234567891011- (void)reset&#123; self.error = nil; self.progress = 0; self.isCanceled = NO; self.isStarted = NO; self.isFinished = NO; self.imageManagerCancelOperation = nil; self.loaderManagerCancelOperation = nil; self.decodeOperation = nil;&#125; 我们现在的状态是符合第二个if的条件的。然后我们的requeset是一个synchronized的请求。暂时可以不用管异步的地方，只要看之后的代码 12345[self dealWithRequest:self.request];[self.imageManager sendRequest:self.request completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache];&#125;]; 先看dealWithRequst: 这个和上边的特效是一样的，添加特效的processers。然后还设置了preferredSize为控件的大小再看下imageManager sendRequest这一句。在setup方法中设置了一个defalut的imageManager. 12345678910111213+ (instancetype)defaultManager&#123; static LKImageManager *instance = nil; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; instance = [[self alloc] initWithConfiguration:nil]; instance.cacheManager = [LKImageCacheManager defaultManager]; instance.loaderManager = [LKImageLoaderManager defaultManager]; instance.processorManager = [LKImageProcessorManager defaultManager]; [instance setConfiguration:[LKImageConfiguration defaultConfiguration]]; &#125;); return instance;&#125; 先看看这个cacheManager.LKImageCacheManager维护了一个LKImageCache的实例的数组。看过源码发现。这个是一个基类,有两个个不同的实现类LKImageMemoryCache,LKImageSmartCache,不过你也定义自己的Cache类型。在LKImageManager的- (void)setConfiguration:(LKImageConfiguration *)configuration方法中添加了对应的Cache: 123456LKImageCacheManager *cacheManager = self.cacheManager; [cacheManager unregisterAllCache]; for (LKImageCache *cache in configuration.cacheList) &#123; [cacheManager registerCache:cache]; &#125; 而在LKImageCacheManager中的- (void)cacheImage:(UIImage *)image forRequest:(LKImageRequest *)request中就是调用了对用的Cache列表的对应的Cache方法，LKImageCache的子类来实现自己的- (void)cacheImage:(UIImage *)image forRequest:(LKImageRequest *)request方法就行了。我们来看下LKImageKit本身提供的两个Cache的方法: LKImageMemoryCache12345678910111213141516171819202122232425262728293031- (void)cacheImage:(UIImage *)image URL:(NSString *)URL&#123; NSString *key = [self keyForURL:URL]; ImagePointer *ptr = NULL; auto it = imageMap.find([key cStringUsingEncoding:NSUTF8StringEncoding]); if (it == imageMap.end()) &#123; ImageNode *node = new ImageNode(); ptr = new ImagePointer(); node-&gt;image = image; node-&gt;key = [key cStringUsingEncoding:NSUTF8StringEncoding]; ptr-&gt;it = FIFOQueue.insert(FIFOQueue.end(), node); imageMap[node-&gt;key] = ptr; if (FIFOQueue.size() &gt; self.maxLengthForFIFO) &#123; ImageNode *node = *FIFOQueue.begin(); FIFOQueue.pop_front(); auto it = imageMap.find(node-&gt;key); delete it-&gt;second; delete node; imageMap.erase(it); &#125; &#125; else &#123; ptr = it-&gt;second; (*ptr-&gt;it)-&gt;image = image; [self visit:key]; &#125; [self limitCacheSize];&#125; 这个类中可以看到一个map&lt;string,ImagePointer *&gt; imageMap实例。在- (void)cacheImage:(UIImage *)image URL:(NSString *)URL中用图片的地址当做key来在map中寻找对应的ImagePointer指针，如果没有找到，就新建一个ImageNode和ImagePointer指针，设置node的image为image,然后在FIFOQueue的列表的尾部添加这个node。然后查看队列的大小时候超出了预定的阈值,如果超过就按照先进先出的策略pop掉第一个，并且在map中也删除掉这个迭代器类型的数据。同事在堆上把node和pointer都free掉。 这边其实基本可以看出map和list的作用了，map是为在O(1)的时间复杂度内找到对应的数据。而list是为了控制缓存的大小. 然后在看下如果map中存在这个key的时候的操作。就是更新下这个key对应的图片，然后调用visit方法，最后调用limitCacheSize方法 先看下visit方法: 1234567891011121314151617181920212223242526- (void)visit:(NSString *)key&#123; auto it = imageMap.find([key cStringUsingEncoding:NSUTF8StringEncoding]); if (it == imageMap.end()) &#123; return; &#125; ImagePointer *ptr = it-&gt;second; ImageNode *node = *ptr-&gt;it; if (ptr-&gt;isLRUQueue) &#123; LRUQueue.erase(ptr-&gt;it); ptr-&gt;it = LRUQueue.insert(LRUQueue.end(), node); &#125; else &#123; ptr-&gt;isLRUQueue = true; FIFOQueue.erase(ptr-&gt;it); ptr-&gt;it = LRUQueue.insert(LRUQueue.end(), node); &#125; if (LRUQueue.size() &gt; self.maxLengthForLRU) &#123; [self clearLastOneInLRU]; &#125;&#125; 这个时候先查看这个ImagePointer的Node是不是在LRUQueue这个列表里边，如果在的话就删除之后再插入到列表的最后去，如果不在的话就在FIFOQueue中删除掉这个node,重新加入到LRUQueue中去，之后再根据LRUQueue的大小来clean下,我们也能想到既然最新visit的是放到最尾部，那么做clean操作的时候肯定就是清除头部了. 然后我们看下limitCacheSize方法,同样的是很简单的根据map中缓存的图片的尺寸x4之后的大小来和阈值比较，在做情况LRUQueue和FIFOQueue的操作。 这样的话，我们也是能简单的想到LRUQueue的作用了，其实就是一层保证越是后边被使用的图片越是不容易被从缓存中清除出去的机制。不过这边代码里边有个疑问的地方在清除数据的时候会先清除LRUQueue： 1234567891011- (void)clearLastOne&#123; if (LRUQueue.size() &gt; 0) &#123; [self clearLastOneInLRU]; &#125; else &#123; [self clearLastOneInFIFO]; &#125;&#125; 感觉上是先FIFOQueue是不是更好一点，毕竟在FIFO中的图片按代码来说只是被用了一次。哪位大佬了解的可以说下 LKImageSmartCache这个比较简单，说使用一个NSMapTable来管理缓存数据就不多说了。 缓存的逻辑基本就是这样啦。~~ 好像在这边并没有看到README中所说的磁盘缓存 ~~ 下一篇分析loader的时候回看到本地磁盘Cache 在看下图片加载的代码,主要是看看发送请求的代码(这边的请求不一定是网络请求。是对图片加载的一种封装，可以想象成操作系统对IO的封装一样) 1234[self.imageManager sendRequest:self.request completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache]; &#125;]; 这个方法正如他的category写的那样是一个语法糖. 12345- (void)sendRequest:(LKImageRequest *)request completion:(LKImageManagerCallback)callback&#123; request.managerCallback = callback; [self sendRequest:request];&#125; 在sendRequest方法中可以看到调用了- (BOOL)checkAndLoadCache:(LKImageRequest *)requestLV0这个方法来加载缓存。我们会看到会在mainqueue中同步的运行block.这边可以看到一个GCD的方法if (dispatch_queue_get_label(queue) == dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)),用于判断当前的queue是否是指定的queue.然后在block中会调用CacheManager的- (UIImage *)imageForRequest:(LKImageRequest *)request continueLoad:(BOOL *)continueLoad方法: 12345678910111213- (UIImage *)imageForRequest:(LKImageRequest *)request continueLoad:(BOOL *)continueLoad&#123; UIImage *image = nil; for (LKImageCache *cache in self.cacheList) &#123; image = [cache imageForRequest:request continueLoad:continueLoad]; if (image) &#123; break; &#125; &#125; return image;&#125; 可以看出其实就是在配置的CacheList中来查找对应的图片了，对应的实现就是也比较简单了，比如MemoryCache就是在map中find这个key对应的数据，SmartCache就是在NSMapTable中找对用的数据,不过这边的continuedLoad参数在源码中提供的两个Cache中都是没有被使用的参数，不知道是什么考虑。获取到缓存之后就会调用request的managerCallback这个block(就是用户传入的回调),同时还会把childRequests的callback也调用一遍，这个requestlist我们以后再来分析:) 到目前为止基本分析完了缓存这块的内容啦。 以后会分下下LKImageRequest和他的子类 == 未完待续 ==]]></content>
      <categories>
        <category>技术</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>LKImageKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B站AV号转音频程序]]></title>
    <url>%2F2018%2F03%2F09%2FB%E7%AB%99AV%E5%8F%B7%E8%BD%AC%E9%9F%B3%E9%A2%91%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[上B站的时候有好多弹幕都是在求BGM的。于是就想不如咱自己写一个东西来分离视频里边的音视频。把音频给抽出来：) 分析基本想法就是分成3步来做啦 准备阶段—&gt;通过av号获取到视频的地址 下载阶段—&gt;获取到下载地址之后下载视频 分离阶段—&gt;分离视频中的音频保存到单独的文件 很简单明确。然后就是找对用的技术啦，最主要的就是分离阶段的技术。我这边选择ffmpeg, 通用的解决方案啦。然后既然是用ffmpeg就要用c/c++来实现比较方便了。最终确定的方案就是这样的: 网络请求—&gt; cURL JSON —&gt; rapidjson 音视频 —&gt;ffmpeg 编码 ffmpeg 下载，make ， make install 建立CMakeList.txt 我是在mac上写的。所有需要加上一些变量，下边的是我的cmakelist文件 1234567891011121314151617cmake_minimum_required(VERSION 3.5)project(BiliBg)#mac/ios build need add some xcode libset(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; -v -std=c++11 -stdlib=libc++ -framework OpenGL -framework AppKit -framework Security -framework CoreFoundation -framework CoreVideo -framework CoreMedia -framework QuartzCore -framework CoreFoundation -framework VideoDecodeAcceleration -framework Cocoa -framework AudioToolbox -framework VideoToolbox -framework OpenCL -I/usr/local/include -L/usr/local/lib/ -I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include -L/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/")set(SOURCE_FILES main.cpp iomodule/BiliMovieDownloader.cpp iomodule/BiliMovieDownloader.h videomodule/BiliMovieDumux.cpp videomodule/BiliMovieDumux.h)add_executable(BiliBg $&#123;SOURCE_FILES&#125;)target_link_libraries(BiliBg curl)target_link_libraries(BiliBg bz2)target_link_libraries(BiliBg z)target_link_libraries(BiliBg iconv.2.4.0)target_link_libraries(BiliBg /usr/local/lib/libavcodec.a)target_link_libraries(BiliBg /usr/local/lib/libavformat.a)target_link_libraries(BiliBg /usr/local/lib/libswscale.a)target_link_libraries(BiliBg /usr/local/lib/libavdevice.a)target_link_libraries(BiliBg /usr/local/lib/libavutil.a)target_link_libraries(BiliBg /usr/local/lib/libswresample.a) 代码其实比较简单分成两个模块： io模块 负责请求，解析，下载 音视频分离模块 读取视频文件获取解码器，分离音视频 代码地址：这里 TODO: (有空的时候有可能做吧) 添加时间参数。分离特定时间的bgm]]></content>
      <tags>
        <tag>FFMPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake实战2]]></title>
    <url>%2F2018%2F03%2F07%2FCMake%E5%AE%9E%E6%88%982%2F</url>
    <content type="text"><![CDATA[4 编写CMakeLists文件这一章主要覆盖了为你的软件编写CMakeLists文件一些基础，我们将会学习到你在大多数项目中遇到的所有的基本命令和一些问题,也会学习下周末把现有的UNIX或者Windows项目转换到CMake上来，因为CMake能处理非常复杂的项目，所以大多数项目中你会发现这一章的内容完全够用啦，CMake是被CMakeLists文件驱动的，CMakeList文件决定一切，比如Cache中的值，需要被编译的文件。最后会讨论下怎么让CMakeLists文件健壮并且可维护，基础的语法和关键概念都已经在上边的章节说过了，这一章将张开这些概念并且引入一些新的东西 4.1 CMake 语法CMakeLists文件遵守一个简单的语法规则(注释，命令，空白符)，注释是从一个#开始的知道行尾，命令是由命令名称，小括号，空白符分割的参数组成的，含有空白符的参数用双引号括起来，反斜线可以做转移符，后边的一些列子会帮你解决语法上困惑，你可能回想CMake为什么不用先用的语言的语法来实现，比如Python啥的，主要的母的是想让CMake不要依赖其他的东西来运行，要是依赖了这些语言的话，安装就会很大,也需要依赖特定版本的语言，我们自己干的话就没有性能和兼容问题啦 4.2 基本命令上一章已经介绍了蛮多基础的基础命令了，这一章将会重新来看下并且要展开来讲下，第一个命令是顶层CMakeLists文件要包含的PROJECT命令，这个命令不仅可以给项目命名还能指定工程使用的语言他的语法如下: 1project (projectname [CXX] [C] [Java] [NONE]) 如果没有指定语言，CMake默认会支持C和C++，如果指定了NONE，CMake将会不包含任何语言支持，当CPP被支持的时候C的支持也会加载的 对于项目中每一个project命令,CMake会创建一个顶层的IDE的project文件，这个项目会包含CMakeLists文件中的所有Target，添加子目录需要使用add_subdirectory命令，如果EXCLUDE_FROM_ALL选项被用在add_subdirectory命令中的话，生产的项目将不会出现在顶层的Make文件或者IDE的项目文件中。这个功能在你想要让你的子目录的项目和你的主项目没啥关系的时候很有用,举个栗子，假设你的工程有很多例子项目,你可以使用这个功能来为你的例子生产编译文件，但是在正常的编译中不会包含例子目录 set命令可能是用的最多的命令，他可以用来定义和修改变量和列表，和set相对的，remove和separate_arguments命令，remove命令可以用来从变量列表里边删除值，separate_arguments可以用来把一个单一的变量值用空白分割成一个列表 add_executable和add_library命令是用来定义库和可执行文件的编译和源码的，加的源码可以包含头文件，反正基于makefile的generators是会简单的省略掉 4.3 流控制在很多方面写一个CMakeList文件就和写一段程序是一毛一样的，所以和其他的编程语言一样，CMake为咱提供了控制流结构： 条件判断语句(例如:if等) 循环结构(例如:foreach和while等) 程序流程定义(例如macro和function等) 首先我们看下if命令，在很多方面和在其他编程语言是一样的，计算表达式的值，根据结果运行命令的体内的代码或者运行可选的else中的代码。举个栗子： 12345if (FOO)# do something hereelse (FOO)# do something elseendif(FOO) 一个你可能注意到的不一样的地方就是if中的条件在else和endif中都会重复写一次，这个是可选的，在这本书里边你将看到两种风格的代码，你可以自己选择： 12345if (FOO)# do something here else()# do something elseendif() if命令有一些使用的限制，它不支持一些像${FOO} &amp;&amp; ${BAR} || ${FUBAR}这样的C类型的表达式，作为替代，它支持一些表达式的子集，大多数情况下，这些就够啦，if命令支持: if(variable) 如果变量的值不是空，0，FALSE, OFF或者NOTFOUND if(NOT variable) 如果变量的值是空，0， FALSE, OFF或者NOTFOUND if(variabl1 AND variable2) 变量同时为真，表达式为真 if(varibale1 OR variable2) 变量一个为真，表达式为真 if(COMMAND command-name) 如果给定的命令名称是一个可调用的命令，表达式为真 if(DEFINED variable) 如果变量被set过，不管这个值是多少，表达式为真 if(EXISTS file-name) if(EXISTS directory-name) 如果文件或者目录存在，表达式为真 if(IS_DIRECTORY directory-name) if(IS_ABSOLUTE name) 如果名称是一个目录或者一个绝对路径，表达式为真 if(name1 IS_NEWER_THAN name2) 最后修改时间文件1比文件2更新，表达式为真 if(variable MATCH regex) if(string MATCH regex) 如果给定的字符串或者变量的值符合正则，表达式为真 EQUAL,LESS,和GREATER可以用作数值比较 STRLESS,STREQUAL,和STRGREATER 可以用作字符字面值的比较 VERSION_LESS,VERSION_EQUAL和VERSION_GREATER可以用来做像major.[.minor[.patch.[.tweak]]]这样的版本比较，像C/C++一样，这些表达式可以组合起来使用来创建更多复杂的比较，举个栗子，考虑下边的这些情况: 1234567891011121314151617181920212223242526272829if ((1 LESS 2) AND (3 LESS 4)) message(&quot;sequence of numbers&quot;)endif()if (1 AND 3 AND 4) message(&quot;series of true values&quot;)endif(1 AND 3 AND 4)if (nor 0 AND 3 AND 4) message (&quot;a flase value&quot;)endif(NOT 0 AND 4 AND 4)if (0 OR 3 AND 4) message (&quot;or statements&quot;)endif (0 OR 3 AND 4)if (EXISTS $&#123;PROJECT_SOURCE_DIR&#125;/help.txt AND COMMAND IF) message(&quot;help text&quot;)endif （EXISTS $&#123;PROJECT_SOURCE_DIR/help.txt AND COMMAND IF&#125;）set (foobar 0)if (NOT DEFINED foobar) message (&quot;foobar is not defined&quot;)endif (NOT DEFINED foobar)if (NOT DEFINED fooba) message (&quot;fooba not defined&quot;)endif 在复合的if语句中，有一个指定运算符的执行的顺序，在下边的表达式中，NOT会在AND之前运行，而不是相反的顺序，因此表达式的结果是false，打印的语句也不会执行，如果AND先运行的话，结果就是true了： 123if (NOT 0 AND 0) message (&quot;this line is nerver executed&quot;)endif (NOT 0 AND 0) CMake 定义了操作符的执行顺序，比如括号内的表达式先支持性，EXISTS,COMMAND,DEFINED和相似的前缀运算符先执行，然后是想EQUAL,LESS,GREATER,STREQUAL,STRLESS,STRGREATER和MATCHS运算符，之后运行NOT运算符，最后是AND和OR,哪些具有相同执行级别的运算符比如AND和OR将会从左到右执行，一旦所有的表达式都执行并得到整个表达式的结果，CMake将ON,1,YES,TRUE,Y当做true,将OFF,0,NO,FALSE,N,NOTFOUND,*-NOTFOUND,IGNORE当做false，计算的值的大小写不敏感的，所有true,True和TRUE是相同的 咱们现在再来看下另外一种控制流命令，foreach,while,macro和function命令是减少你CMakeLists文件大小并保证可维护性的的最好的命令，foreach命令可以让你在一个列表中重复运行一组CMake命令，我们看看下边VTK中的栗子： 12345678910111213141516foreach (tfile TestAnisotropicDiffusion2D TestButterworthLowPass TestButterworthHighPass TestCityBlockDistance TestConvolve )add_test ($&#123;tfile&#125;-image $&#123;VTK_EXECUTABLE&#125; $&#123;VTK_SOURCE_DIR&#125;/Tests/rtImageTest.tcl $&#123;VTK_SOURCE_DIR&#125;/Tests/$&#123;tfile&#125;.tcl -D $&#123;VTK_DATA_ROOT&#125; -V Baseline/Imaging/$&#123;tfile&#125;.png -A $&#123;VTK_SOURCE_DIR&#125;/Wrapping/Tcl )endforeach (tfile) foreach的第一个参数是在循环中使用的变量名。剩余的参数是用来做循环的列表的值，在栗子中的foreach循环只是一个CMake命令add_test,在foreach的循环体内部任何时候都可以使用循环变量(tfile)来指代列表中在当前迭代中的元素，在第一次迭代中，${tfile}将会被TestAnisotropicDiffusion2D替换，下一个迭代${tfile}将会被TestButterworthLowPass替代,foreach将会继续循环知道所有参数都被处理完为止 值得一提的是，foreach可以嵌套使用，循环变量在任意表达式之前被替换成列表中的值，这意味着，在foreach的循环体中可以使用循环变量来创建新的变量名，下边的代码循环变量tfile被展开，然后和_TEST_RESULT组合起新的变量，新变量的名字被展开和并当场if的条件表达式来运算: 123if ($&#123;$&#123;tfile&#125;_TEST_RESULT&#125; MATCHES FAILED) message (&quot;Test $&#123;tfile&#125; failed&quot;)endif() 原文中if表达式的参数是${${tfile}}_TEST_RESULT} MATCHES FAILED,应该是有问题的 while命令提供了一个基于条件判断的循环，条件表达式的格式和if是一样的，考虑下边CTest中使用的栗子，注意CTest在内部更新了CTEST_ELAPSED_TIME的值： 12345678################################################################################# run paraview and ctest dashboards for 6 hours# while ($&#123;CTEST_ELAPSED_TIME&#125; LESS 36000) set (START_TIME $&#123;CTEST_ELAPSED_TIME&#125;) ctest_run_script (&quot;dash1_ParaView_vs71continuous.cmake&quot;) ctest_run_script (&quot;dash1_cmake_vs71continuous.cmake&quot;)endwhile() foreach和while命令可以让你处理重复的任务，macro和function命令支持把散落在CMakeLists文件中的重复的任务打包。一旦他们被定义，任何在定义之后CMakeLists文件都可以使用他们 CMake中的function和C/C++中的function很相似，你可以传递参数，在方法内部参数变成了变量，就像其他的标准变量ARGC,ARGV,ARGN和ARGV0,ARGV1等等，在function内部，你就在一个新的变量作用域中了，有点像你使用add_subdirectorty命令进入了一个新的子目录使用新的变量作用域一样，所有定义的变量在方法调用中还是被定义的，但是任何在对这些变量的改变或者新的变量都只存在于方法内部，当方法返回之后，这些都会消失不见，更简单点说，当你调用一个方法是，一个新的变量作用域被push到栈顶，当你从方法返回时，作用域被pop掉 function 的第一参数是方法名称，剩下的参数都是function的正式参数啦： 123456789function (DetermineTime _time) # pass the result up to whatever invoked this set ($&#123;_time&#125; &quot;1:23:45&quot; PARENT_SCOPE)endfunction()DetermineTime( current_time ) if (DEFINED current_time) message(STATUS &quot;the time is now: $&#123;current_time&#125;&quot;)endif 注意这个栗子中的_time被用作返回值的名称，set命令使用_time的值。这个栗子中就是current_time,最后set命令使用PARENT_SCOPE选项来设置变量的值到父作用域 macro的定义和调用在默写方面是和function是一样的，主要的不同点在于，macro没有push和pop新的变量作用域，并且参数不是作为变量，而是作为字符串在运行前被替换的，这些很像C/C++里边的方法和宏的区别。 第一个参数作为macro的名字，后边的作为参数 1234567891011#define a simple macromacro (assert TEST COMMENT) if (NOT $&#123;TEST&#125;) message (&quot;Assertion failed: $&#123;COMMENT&#125;&quot;) endif(NOT $&#123;TEST&#125;)endmacro(assert)#use the macrofind_library (FOO_LIB foo /usr/local/lib)assert ($&#123;FOO_LIB&#125; &quot;Unable to find library foo&quot;) 上边的简单例子中创建了一个叫做assert的宏，这个宏使用了两个参数，第一个是用于测试的值，第二个是如果测试失败打印的字符串，macro的宏体内是一个简单的if命令和一个message命令。macro用一个endmacro来作为结束，macro可以像一个普通的命令一样被调用，在上边的例子中，如果FOO_LIB没找到，就会显示一条信息来表示错误情况 macro命令同样支持定义使用参数列表的宏，当你想要用可变参数或者多签名(???)时会很有用。可变参数可以使用ARGC,ARGV0,ARGV1等来引用，ARGV0表示宏的第一个参数，ARGV1代表下一个，以此类推，你甚至可以使用最少的正式参数和可变参数.下边举个栗子： 1234567891011121314151617# define a macro that takes at least two arguments# (thr formal arguments) plus an optional third argumentmacro (assert TEST COMMENT) if (NOT $&#123;TEST&#125;) message (&quot;Assertion failed :$&#123;COMMENT&#125;&quot;) # if called with three arguments then also write the # message to a file specified as the third argument if ($&#123;ARGC&#125; MATCHES 3) file (APPEND $&#123;ARGV2&#125; &quot;Assertion failed: $&#123;COMMENT&#125;&quot;) endif ($&#123;ARGC&#125; MATCHES 3) endif (NOT $&#123;TEST&#125;)endmacro (assert)#use the macrofind_library (FOO_LIB foo /usr/local/lib)assert ($&#123;FOO_LIB&#125; &quot;Unable to find library foo&quot;) CMake有连个命令用于打断执行流，break命令可以打断foreach和while循环的正常执行，return命令将从方法或者listfile的正常结束之前返回 在这个栗子中，TEST和COMMENT是两个必备的参数，像这个例子中一样这些必备参数可以使用名称来引用,也可以使用ARGV0,ARGV1,如果你想要把参数当成列表来使用，你可以使用ARGV和ARGN变量，ARGV(相对于ARGV0,ARGV1等等)是一个宏的全参数列表，ARGN是正式参数之后的参数列表，在宏体内，你可以使用foreach命令来遍历ARGV或者ARGN 4.4 正则表达式有些CMake命令比如if和string会使用正则或者使用正则作为一个参数，在简单的模式下，一个正则是一系列的字符用于匹配搜索确切的字符，不过，很多时候我们不知道确切的字符串是什么，或者只知道字符串的开头和结尾，因为有好几种不同的方式来指定正则，CMake的标准制动如下: 正则可以使用标准的字母数字组合来指定，并使用下边的这些元字符： ^ 匹配以一行或者一个字符串的开始 $ 匹配一行或一个字符串的结尾 . 匹配一个处理换行外的任意字符 [] 匹配中间的任意字符 [^ ] 匹配不在符号中间的任意字符 [ - ] 匹配范围 * 匹配前一个模式0次或多次 + 匹配前一个模式1次货多次 ? 匹配前一个模式0次或1次 () 保存匹配的表达式，后边可以再用 (|) 匹配|左边或者右边的模式 注意上边的这些元字符可以在单一的模式中使用不止一次用来创建一个复杂的搜索模式，举个栗子，[^ab1-9]匹配任意的不是以a,b或者数字开头的字符序列,下边的栗子可以帮助我们了解正则的用法: ^hello只匹配哪些以hello开头的字符串，他可以匹配&quot;hello there&quot;, 但是不匹配&quot;hi,\n hello there&quot;. long$ 匹配 long结尾的字符串，他匹配so long,不匹配long ago t..t..g 匹配一个t然后两个字符，另一个t和连个字符，最后是一个g,可以匹配testing或者test again, 但是不能匹配toasting. [1-9ab]匹配1-9数字和a,b, 他可以匹配hello 1或者begin 但是不匹配no-match [^1-9ab]匹配任意的非1-9的数字和非a,b的字母，他不匹配1ab2和b2345a,但是可以匹配no-match br*匹配以一个b开头跟着0个或多个r并且以空格结尾的字符串，他可以匹配brrrrr和b,但是不能匹配brrh br+匹配以b开头跟着一个或多个r并且以空格结尾的字符串，他可以匹配brrrrr和br，但是不匹配b或者brrh br?匹配以一个b开头跟随0个或者1个r并且以空格结尾的字符串，他可以匹配br和b，但是不匹配brrrrr或者brrh (..p)b匹配以pb结尾，任意两个字符在第一次遇到p的时候，可以在rep drepaqrepb搜索到repb, (..p)a可以在repa drepb qrepb中搜索到repa qrepb d(..p)匹配那些以d开头，以p结尾并且中间包含两个字符，并且这两个字符与第一次遇到p之前的是相同的，他可以在rep drepa qrepb中搜索到drepa qrepb 4.5 检查CMake的版本CMake是一个不断进化的程序，新的功能和命令随着新版本不停的发布，这就会导致一个问题，你可能想要使用一个在最新版本中的命令，但是在旧版本中却不支持，有好几种方法可以处理这种问题，一种选择就是使用if命令来检查命令是否存在，举个栗子： 123456# test if the command existsif (COMMAND some_new_command) #use the command some_new_command (ARGS...)endif(COMMAND some_new_command) 上边的方法大多数情况下都是适用的，但是如果你想要得到更多的信息，你可以使用CMAKE_VERSION变量来测试当前正在运行的CMake的版本，举个栗子： 12345# look for newer version of CMakeif ($&#123;CMAKE_VERSION&#125; VERSION_GREATER 1.6.1) #do something special hereendif () 当编写CMakeLists文件的时候你可以指定不支持旧版本的CMake。要使用这个功能只需要把下边的命令放在CMakeLists文件的最上边就行啦: 1cmake_minimum_required (VERSION 2.2) 这一行指定了，要在你的项目上运行CMake，版本必须大于等于2.2, 如果在老版本上运行，会显示一条错误信息来提示你需要的CMake的最小版本号 最后，有些情况下，新版本会废弃掉一些命令，这个时候你可以使用CMake policies 下边的4.7会讲到 4.6 使用模块CMake支持代码复用，CMakeLists可以使用可复用的模块。CMake对于这些复用的代码称作section，可以在CMake安装的模块子目录中找到. 模块就是简单的把CMake命令放在一个文件里边。举个栗子，之后可以使用#include命令引入进来，举个栗子，下边的命令将会引入FindTCL模块，并添加Tcl库到FOO目标中:12include (FindTCL)target_link_libraries (FOO $&#123;TCL_LIBRARY&#125;) 模块的位置可以使用绝对路径指定，或者可以让CMake自己去寻找，CMake会在CMAKE_MODULE_PATH指定的地址中寻找模块，如果没有找到，会在CMake的模块目录中寻找。这样项目可以覆盖CMake提供的模块来适配自己的需求，模块可以分成下边的几种主要的类型: Find Modules 这些模块决定了软件的组件比如头文件或者库的位置 System Introspection Modules 这些模块测试系统的一些属性，比如float的大小，ANSI C++ 流的支持等等 Utility Modules 这些模块提供了额外的一些功能，比如一个CMake项目基于另外一个，和一些其他的方便的路由 现在让我们来详细的看下这三种模块,CMake引入了大量的Find Modules，他们的目的是定位软件的组件，比如头文件或者库文件，如果不能找到，他们会提供一个cache件让用户可以设置需要的属性，考虑下边的用于寻找PNG库的模块：123456789101112131415161718192021222324252627282930313233343536# # find the native PNG includes and library## this module defines# PNG_INCLUDE_DIR ,用于寻找 png.h 等# PNG_LIBRARIES 用于链接的PNG库# PNG_DEFINITIONS 你应该在编译引入png库的代码文件之前调用add_definitions ($&#123;PNG_DEFINITIONS&#125;) # PNG_FOUND 如果是false，不要使用PNG# 被定义了,不过一般情况下不用# PNG_LIBRARY 哪里寻找PNG Library# None of the above will be defined unless zlib can be found# PNG depends on Zlibinclude (FindZLib.cmake)if (ZLIB_FOUND) find_path (PNG_PNG_INCLUDE_DIR png.h /usr/local/include /usr/include) find_library (PNG_LIBRARY png /usr/lib /usr/local/lib ) if (PNG_LIBRARY) if (PNG_PNG_INCLUDE_DIR) # png.h includes zlib.h .Sigh set (PNG_INCLUDE_DIR $&#123;PNG_PNG_INCLUDE_DIR&#125; $&#123;ZLIB_INCLUDE_DIR&#125;) set (PNG_LIBRARIES $&#123;PNG_LIBRARY&#125; $&#123;ZLIB_LIBRARY&#125;) set (PNG_FOUND &quot;YES&quot;) if (CYGWIN) if (BUILD_SHARED_LIBS) # NO need to define PNG_USE_DLL here, because it&apos;s default for cygwin else (BUILD_SAHRED_LIBS) set (PNG_DEFINITIONS -DPNG_STATIC) endif(BUILD_SHARED_LIBS) endif (CYGWIN) endif() endifendif() 头部的文档已经说明了模块的功能和模块定义的变量,他引入了另一个模块–FindZLIB模块，他会确认Zlib库是不是已经安装了，再然后，如果ZLib被找到了，find_path命令用来定位PNG的头文件，第一个用于保存结果，第二个参数是需要找的头文件的名字，剩余的参数是用于寻找这个头文件的路径，如果在系统目录中没有找到，变量会被设置成PNG_PNG_INCLUDE_DIR-NOTFOUND,用户可以修改这个值 注意搜搜PNG库的路径可以包含硬编码的目录，注册条目，使用其他CMake变量创建出来不的目录，下一个命令find_library寻找PNG库真正位置。这个命令会检查来寻找正确的库名，比如Linux上在名称前添加lib,在名称后边添加.so 在find运行之后，设置了一些CMake变量，使用FindPNG模块的开发者可以使用这些变量(比如include路径，库的名称)，最后PNG_FOUND设置正确让使用的开发者知道PNG库被正确的找到了 这个结构在CMake寻找模块中中是正常操作，通常都很短，但是在默写情况下，比如FindOpenGL可能有几页长，他们通常是独立于其他模块的，但是没有使用其他模块的限制 系统自省模块可以提供关于目标平台或者编译器的信息，模块可以提供关于目标平台或者编译器的信息, 很多这种模块都有一个以Test或者Check的前缀，比如TestBigEndian和CheckTypeSize，很多系统自省模块实际上是尝试去编译代码来判断结果是否正确，这些情况下，源码文件的名称和模块经常是一样的，只是加上一个.c或者.cxx的后缀，在第五章会详细说说系统自省模块 CMake包含一些工具模块帮助你更简单的使用CMake，CMakeExportBuildSettings和CMakeImportBuildSettings提供了帮助检验两个不同的C++项目是否使用看了相同的编译器和参数的工具，CMakePrintSystemInfomation模块打印出在debug程序是有用的关键的CMake设置信息 SWIG中使用CMake一个很好的使用模块的栗子就是看看怎样使用SWIG把你的C/C++代码包装成另外一种语言.SWIG(Simplified Wrapper and Interface Generator)就是一个创建胶水语言（不翻了），CMake可以使用find_package命令支持SWIG.尽管SWIG可以做CMake中作为客户话的命令使用。不过SWIG包提供了一些宏来是创建SWIG项目相对简单点，要使用这些宏，首先使用find_package命令SWIG的名称做为参数，然后你需要引入]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake实战]]></title>
    <url>%2F2018%2F03%2F07%2FCMake%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[2.3 cmkae基本语法和语法使用cmake很简单,build过程被创建的CMakeLists.txt文件所控制,包含在子目录中的CMakelists.txt文件，CMakeLists文件应该描述了项目的结构,基本的命令的形式如下: command (args ...) args 是用空白符分开的参数列表(参数如果包含空格，就用双引号包含下),CMake是大小写不敏感的(2.2之后)所以你可以使用command或者COMMAND CMake支持简单的变量比如字符串或者字符串列表，使用${变量}来引用, 多个参数可以使用set命令打包到列表中去，所有的其他命令会展开用空白符分隔来展开列表 举个栗子 set (Foo a b) 命令的结果是将a,b,c包进Foo变量，所以如果传递Foo到另外一个命令COMMAND(${Foo})和COMMAND(a b c)是一样的 如果你想要将列表传递给命令作为一个单独的参数，只需要简单的用双引号包括以下就行 再举个栗子 COMMAND(&quot;${Foo}&quot;) 和 COMMAND(&quot;a b c&quot;)是一样的效果 系统环境变量和Windows的注册变量(注册表啥的吧，不懂:&lt;)在CMake中都可以访问，要访问系统环境变量使用$ENV{变量}语法，CMake还可以在很多不同的命令中使用[HKEY_CURRENT_URSER\\Software\\path1\\path2;key]引用注册变量,这些路径是注册树和key 2.4 CMake Hello World咱们来看个简单的吧:), 为了从源码中编译出一个可执行文件，CMake需要一个CMakeLists.txt文件，文件中需要包含两行: project (Hello) add_executable (Hello Hello.c) 为了编译出Hello可执行文件，咱们运行CMake来生成Makefiles或者巨硬的项目文件。 project命令标识了结果的工作空间应该叫什么 add_executable命令向编译程序添加了一个可执行的目标 如果你的项目需要不是特别多的源文件，只需要简单的修改下add_executable就好啦: add_executable(Hello Hello.c File2.c File3.c File4.c) add_executable只是CMake众多命令中的一件。咱们来看看一个更不清真的栗子: 1234567891011121314151617cmake_minimum_required(2.6)project (HELLO)set (HELLO_SRCS Hello.c File2.c File3.c)if (WIN32) set (HELLO_SRCS $&#123;HELLO_SRCS&#125; WinSupport.c) else () set (HELLO_SRCS $&#123;HELLO_SRCS&#125; UnixSupport.c) endif ()add_executable (HELLO $&#123;HELLO_SRCS&#125;)#look for thr Tcl libraryfind_library (TCL_LIBRARY NAMES tcl tcl84 tcl83 tcl82 tcl80 PATHS /usr/lib /usr/local/lib)if (TCL_LIBRARY) target_link_library(Hello $&#123;TCL_LIBRARY&#125;) endif () 这个栗子里边使用set命令来打包参数列表，使用if命令来添加各自平台的支持文件，最后使用了add_executable命令来编译可执行文件，find_library命令搜索TCL_LIBRARY使用了不同的名称和不同的路径，使用一个if命令来判断TCL_LIBRARY是否找到，如果找到了就把他link到可执行文件的target中，注意#作为一个注释来使用，从#到行尾都是注释部分 2.5 如何运行CMake只要你系统里边装了CMake，使用它来编译项目很简单，CMake用两个主要的目录来编译项目:源码目录和二进制目录。源码目录里边包含源码和CMakeLists.txt文件。二进制目录就是放可执行文件，库，目标文件这些东西的，一般来说，CMake不会在源码目录里边写东西，只在二进制目录里边干活，如果你想让CMake在源码目录里边写东西的话:&lt;(一般不要这么做吧，不明白什么时候需要这么干)，就把源码目录和二进制目录设置成一样的就妥了这个就是–in-source-build。相对的就是out-source-build。 CMake在所有平台上两种方式都是资瓷的。就是说你用out-source-build的时候你可以简单地删除掉所有编译期间生产的文件。拥有不同的编译路径和源码路径让资瓷对同一份代码的多个编译很简单，这个功能在你想要用不同的编译选项编译同一份代码的时候很有用。CMake还有一个QT的GUI(蛤，我为什么要用这个，反正我不用，我就不翻了) 在控制台运行CMake在命令行上，CMake可以当成一个交互的问答式的会话或者是一个无交互的程序。加上-i参数就可以启动交互模式，交互模式下Cmake将会为每一个参数询问你。CMake将会提供有效的默认值。CMake将问完所有的问题然后停止 使用无交互模式编译项目在不需要参数或者很少参数的时候很简单。对于大型的项目像VTK,使用gui或者cmake -i比较推荐。 使用CMake的无交互模式，首先cd到你想要放二进制的目录,in-source-build的话就直接运行cmake,加上-D来传递编译选项。out-source-build的话同样的操作，只是需要你添加上源文件的目录作为cmake的参数。然后使用make命令来编译你的项目，有些项目会包含 install 目标，你可以使用make install来安装他们 指定编译器有时候在你的操作系统里边可能包好不止一个编译器或者编译器不在标准的路径下边，这个时候你告诉CMake你想要用的编译器在什么地方。有三种方法可以实现这个功能: generator可以指定编译器 设置环境变量参数 设置一个缓存实例 默写generator可以绑定在特定的编译器，例如宇宙第一IDE的generator就是绑定到VS的编译器的。基于Makefile的generator会尝试一个常用的编译器列表。一般这个列表可以在这些文件中找到: Modules/CMakeDeterminCCompiler.cmakeModules/CMakeDeterminCxxCompiler.cmake 这个列表可以被环境变量覆盖掉。 CC 环境变量用来指定C编译器 CXX 用来指定c++编译器 你可以使用——DCMake_CXX_COMPILER=cl直接在命令行上指定编译器。如果不设置这个的话，CMake会依次选择下边的这些编译器: c++ g++ CC aCC cl bcc xlC CMake开始运行并且选好编译器之后,你可以修改缓存选项CMAKE_CXX_COMPILER和CMAKE_C_COMPILER修改选择的编译器，不过这种做法是不推荐的，这么做的问题主要是项目可能是你的配置可能已经运行了一些基于编译器的测试来判断一些支持特性。修改了编译器之后可能会导致一些不正确的结果。如果你必须修改编译器。重在一个新的空的二进制目录中进行。编译器的flags和链接器同意可以使用环境变量来修改。设置LDFLAFGS将会为link flag初始化一个缓存值,同样的CXXFLAGS和CFLAGS将会初始化CMAKE_CXX_FLAGS和CMAKE_C_FLAGS 依赖分析CMake拥有一个强大的内置C/C++依赖分析能力,CMake还支持部分的Java和Fortran依赖分析，因为IDE支持和维护了依赖信息，CMake对这些编译系统放弃了这部分功能，但是，Makefiels是不了解怎么样去计算和维护依赖信息的，对于这些系统，CMake为C/C++/Fortran自动计算依赖信息，CMake自动生成和维护依赖信息，这些都是自动完成的，如果一个项目是用CMake配置的，用户主需要运行Make，CMake会帮你完成剩余的工作，对于多处理器系统CMake完全支持并行编译 尽管用户不需要知道CMake是如何工作的，不过看一下项目的依赖信息文件也没啥坏处:),为每一个target创建的依赖文件保存在这四个文件中： depend.make flags.make build.make DependInfo.cmake depend.make保存了目录中的所有目标文件的所有的依赖信息flags.make包含了编译的flags 这两个文件如果改变了，源码就会被重新编译 DependInfo.cmakes是保持更新信息更新，并且包含了项目中包括哪些文件和这些文件使用的语言最后编译依赖的规则保存在build.make中，如果依赖不是过期了，所有的依赖需要重新计算来保持信息永远是最新的 2.6 编辑 CMakeLists 文件CMakeLists文件可以用几乎任意的文本编辑器来编辑,有些编辑器比如Notepad++内置了语法高亮和缩进支持，神的编辑器和编辑器之神也内置了语法和缩进支持 这段没啥营养啦，反正我用vim… 2.7 为CMake设置初始值尽管CMake在交互模式下运行的很好，有时你也可能在没有GUI的时候设置下缓存条目，这种情况是很常见的当设置nightly dashboard(不明白这边)或者是你将创建很多编译树使用相同的cahce值，在这些情况下，CMake缓存可以以两种方式被初始化，第一种方式是使用CMake命令行下-DCACHE_VAR:TYPE=VALUE传递cache值 再举个栗子 考虑下边的nightly dashboard脚本: 12345678910#!/bin/tcshcd $&#123;HOME&#125;#wipe out the old binary tree and then create it againrm -rf Foo-Linuxmkdir Foo-Linuxcd Foo-Linux#run cmake to setup the cachecmake -DBUILD_TESTING:BOOL=ON &lt;etc...&gt; ../Foo#generate the dashboardctest -D Nightly 同样的方法可以用在windows的批处理文件上 第二种方式是创建一个文件用来被CMake -C选项来加载。这种情况下取代-D这种方式的是使用一个文件来使用CMake解析，这个文件的语法就是标准的CMakeLists语法，通常来说就是一系列的set命令像这样的： 12#Build the vtkHybrid kit alwaysset (VTK_USE_HYBRID ON CACHE BOOL "doc" FORCE) 还有一种方法是你想要设置一个变量然后隐藏他，用户不会改变这个值，用下边的命令可以实现 123#Build the vtkHybrid kit alwaysset (VTK_USE_HYBRID ON CACHE BOOL "doc" FORCE)mark_as_advanced (VTK_USE_HYBRID) 你可能会想直接编辑cache文件，或者去“初始化”一个项目通过给他一个初始的cache文件的方式，这有可能跑不出来，或者在以后出现问题，首先，CMake cahe的语法是修改的东西，第二，cache 文件包含了完整路径。 2.8 编译你的项目运行完了CMake之后就可以准备编译了。如果你的编译系统是基于make的，你就cd到你的二进制目录然后运行make就行啦，如果是IDE的话就加载生产的项目文件，然后你按你平时的操作来就行了 另外一种选择就是在命令行中使用CMake的编译选项，这个选项就是一个便利的工具让你在命令行编译你的项目运行下cmake -build你就知道怎么用了。 [不清楚的地方] nightly dashboard]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>
