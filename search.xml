<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LKImageView源码分析2]]></title>
    <url>%2F2018%2F03%2F15%2FLKImageView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%2F</url>
    <content type="text"><![CDATA[接着上一次的LKImageManager中的combineRequest:方法继续分析。可以看到这边使用了一个在初始化时使用的NSOperationQueue,在初始化方法中我们可以看到，这个queue是一个maxConcurrentOperationCount是1的queue,可以把他当成一个同步的queue来看了。在combineRequest:方法中我们看到这个queue使用了一个类别方法- (void)lk_addOperation:(NSOperation *)op request:(LKImageRequest *)request，看看源码十分简单，通过reques的同步与否来看是直接运行opeation还是加入到queue中去等待执行。operation是通过blockOperationWithBlock方法创建的。可以看看其中的实现:123456789101112131415161718192021222324252627282930313233343536if (requestLV0.isCanceled)&#123; atomic_fetch_sub(&amp;LKImageRunningRequestCount, 1); atomic_fetch_add(&amp;LKImageCancelRequestCount, 1); requestLV0.isFinished = YES; requestLV0.error = [LKImageError errorWithCode:LKImageErrorCodeCancel]; [requestLV0 managerCallback:nil isFromSyncCache:NO]; [requestLV0.imageManagerCancelOperation cancel]; requestLV0.imageManagerCancelOperation = nil; return;&#125;LKImageLogVerbose([NSString stringWithFormat:@&quot;LKImageManagerProcessRequest:%@&quot;, requestLV0]);LKImageRequest *requestLV1 = nil;requestLV0.error = nil;if (!requestLV0.synchronized)&#123; requestLV1 = [self.requestDic objectForKey:requestLV0.identifier];&#125;if (requestLV1)&#123; LKImageLogVerbose([NSString stringWithFormat:@&quot;ManagerRequestCombine:%@&quot;, requestLV1]); [requestLV1 addChildRequest:requestLV0]; return;&#125;else&#123; requestLV1 = [requestLV0 createSuperRequest]; if (!requestLV0.synchronized) &#123; LKImageLogVerbose([NSString stringWithFormat:@&quot;ManagerRequestCreate:%@&quot;, requestLV1]); [self.requestDic setObject:requestLV1 forKey:requestLV1.identifier]; &#125;&#125;[self loadRequest:requestLV1]; 先看到的是参看isCanceled属性。如果是cancel的话就使用无锁系统函数来更新请求个数。并且把reques的状态更新。然后是- (void)managerCallback:(UIImage *)image isFromSyncCache:(BOOL)isFromSyncCache方法,这个方法我们上一篇说过就是调用request和requestList的回调方法,然后清除imageManagerCancelOperation然后看下LKImageRequest的addChildRequest:方法.基本上是同步下请求的属性到superRequest中，并且在requestList中添加。createSuper方法调用了copy这个方法值得留一下: 123456789101112131415161718192021222324252627282930313233343536373839- (id)copy&#123; LKImageRequest *request = [[[self class] alloc] init]; Class cls = [self class]; while (cls != [NSObject class]) &#123; unsigned int numberOfIvars = 0; Ivar *ivars = class_copyIvarList(cls, &amp;numberOfIvars); for (const Ivar *p = ivars; p &lt; ivars + numberOfIvars; p++) &#123; Ivar const ivar = *p; NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)]; if (key == nil) &#123; continue; &#125; if ([key length] == 0) &#123; continue; &#125; id value = [self valueForKey:key]; @try &#123; [request setValue:value forKey:key]; &#125; @catch (NSException *exception) &#123; &#125; &#125; if (ivars) &#123; free(ivars); &#125; cls = class_getSuperclass(cls); &#125; return request;&#125; 可以看到这个方法是遍历本身的class的超类。并且获取对应的ivar数据，这边给我提供了一个新的设置值的思路，就是通过获取ivar的name来创建出一个key，然后通过key使用kvc来做值的设置，一般情况下，我们都是使用object_setIvar(&lt;#id _Nullable obj#&gt;, &lt;#Ivar _Nonnull ivar#&gt;, &lt;#id _Nullable value#&gt;)这个方法来做ivar的赋值的，一般情况下对于非类类型的ivar需要做方法的类型转换。这个就不能像上边那样做到使用kvc这种通用的方法来实现，这种应该还是是只适应于像LKImageRequest这种没有私有的值包含ivar，不包含setter的方法的类型。这个操作可以的 在copy之后会把对用的callback清空，防止多次调用。之后会调用loadRequest:(LKImageRequest *)requestV1. 这边会用到一个大一点的类LKImageLoaderManager LKImageLoaderManager从这个类的初始化函数中，可以看出需要两个数组，一个LKImageLoader数组和一个LKImageDecoder数组。在实例中还包含一个LKImageDecoderManager LKImageLoader这个类本身可以看做一个虚基类，包含了一个NSOperationQueue,一个gcdqueue(同步)和一个gcd信号。 我们看到在configuration中包含了5中源码中提供的LKImageLoader的子类 我们一个一个看下： LKImageBundleLoader- (void)imageWithRequest:(LKImageRequest *)request callback:(LKImageImageCallback)callback方法被复写。代码很简单，就是看request的URL是不是含有后缀，有的话就在主bundle里边找到对应的图片，没有后缀的会就直接imageNamed加载。主要应该是用来应对imageNamed加载不到的类型的图片,JPEG什么的然后就是调用callback了]]></content>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LKImageView源码分析]]></title>
    <url>%2F2018%2F03%2F13%2FLKImageView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LKImageKit是腾讯开源的基于OC的图片管理类的集合框架 在项目主页上的README中说明包含了3个模块: 加载模块 解码模块 缓存模块 我们采用从上到下的分析方式来解析它的代码，首先是最常用的类LKImageView 从几个init方法中可以看出来，启动一个LKImageView的代码都需要调用setup方法，在这个方法中其实就是初始化了一个用于展示的imageView实例,并对于一些属性设置了default值，比较简单并且还新建了一个LKImageManager实例，这个会在后边解释既然添加了subview,就看下layoutSubviews方法,看到调用了layoutAndLoad方法。这个方法会根据图片的size,scale在加上屏幕的scale和控件的大小以及contentMode计算出imageView的frame.比如: LKImageScaleModeNone 为居中显示图片，使用图片本身的大小 (不会变形) LKImageScaleModeScaleToFill 直接使用控件大小平铺 (可能变形) LKImageScaleModeAspectFit LKImageScaleModeAspectFill都是不会变形的缩放,差距只是在控件和图片本身的宽高比大小比较时选取的基准的不同 之后还会调用加载图片的代码，在后边会展开代码来解析. 下一步来看下加载本地图片的时候是怎么做：LKImageViewoverwrite了setImage方法: 12345678910111213- (void)setImage:(UIImage *)image&#123; self.loadingImageRequest = nil; self.failureImageRequest = nil; if (image) &#123; self.request = [LKImageImageRequest requestWithImage:image]; &#125; else &#123; self.request = nil; &#125;&#125; 这边也算是比较好理解的了。如果传入的图片不是nil，就会新建一个LKImageImageRequest实例并且set给自身的属性 然后再看下LKImageImageRequest这个类的实现，基类是LKImageRequest. 12345678+ (instancetype)requestWithImage:(UIImage *)image key:(NSString *)key&#123; LKImageImageRequest *request = [[LKImageImageRequest alloc] init]; request.image = image; request.keyForLoader = [NSString stringWithFormat:@&quot;%p&quot;,image]; request.synchronized = YES; return request;&#125; 基本可以确定对于本地图片是同步加载的。不过这个方法里边这key就有点尴尬啦，完全没有用到:(, keyForLoader取的key是这个image的内存地址。在研究这个Request的代码之前我们先回过来看下LKImageView的setRequest方法 12345678910111213141516171819- (void)setRequest:(LKImageRequest *)request&#123; request.internalProcessorList = self.processorList; if (![_request isEqual:request] || _request.error) &#123; [self.imageManager cancelRequest:_request]; _request = request; &#125; if (!_request) &#123; [self internalSetImage:nil withRequest:nil]; &#125; [self setNeedsLayout]; if (!self.delayLoadingImage) &#123; [self layoutIfNeeded]; &#125;&#125; internalProcessorList这个数组是图片的处理模块的processor，就是加特效 代码中看到的就是blur和gray两个东西 然后看如果原先的request和设置的新的requset不是相同的或者原先的请求出现error的话就会走到imageManager cacheRequest的代码。这块先略过然后就会发现代码调用了setNeedsLayout和layoutIfNeeded方法，这个时候就会回到上边说的layoutSubviews方法和layoutAndLoad了，我们上面没有展开这个代码，只是说了frame的变化。现在详细展开之后: 1234567891011121314151617181920212223242526272829303132333435363738- (void)layoutAndLoad&#123; [self layoutImageView]; if (self.request.state == LKImageRequestStateFinish &amp;&amp;!CGSizeEqualToSize(self.oldSize, self.size) &amp;&amp;(!self.presentationImage||self.presentationImage.lk_isScaled)) &#123; [self.request reset]; &#125; if (self.request &amp;&amp; self.request.state == LKImageRequestStateInit) &#123; self.oldSize = self.size; __weak LKImageView *wself = self; if (!self.request.synchronized) &#123; if (self.loadingImageRequest) &#123; [self dealWithRequest:self.loadingImageRequest]; [self.imageManager sendRequest:self.loadingImageRequest completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache]; &#125;]; &#125; &#125; [self dealWithRequest:self.request]; [self.imageManager sendRequest:self.request completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache]; &#125;]; &#125;&#125; 第一步是上面说过的计算imageView的frame的代码,剩余的代码是对request的操作,假设我们第一次调用这个方法也就是说这个request刚刚被alloc出来，所以这个时候state==LKImageRequestStateInit，所以走不到reset，其实reset相当于情况状态: 1234567891011- (void)reset&#123; self.error = nil; self.progress = 0; self.isCanceled = NO; self.isStarted = NO; self.isFinished = NO; self.imageManagerCancelOperation = nil; self.loaderManagerCancelOperation = nil; self.decodeOperation = nil;&#125; 我们现在的状态是符合第二个if的条件的。然后我们的requeset是一个synchronized的请求。暂时可以不用管异步的地方，只要看之后的代码 12345[self dealWithRequest:self.request];[self.imageManager sendRequest:self.request completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache];&#125;]; 先看dealWithRequst: 这个和上边的特效是一样的，添加特效的processers。然后还设置了preferredSize为控件的大小再看下imageManager sendRequest这一句。在setup方法中设置了一个defalut的imageManager. 12345678910111213+ (instancetype)defaultManager&#123; static LKImageManager *instance = nil; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; instance = [[self alloc] initWithConfiguration:nil]; instance.cacheManager = [LKImageCacheManager defaultManager]; instance.loaderManager = [LKImageLoaderManager defaultManager]; instance.processorManager = [LKImageProcessorManager defaultManager]; [instance setConfiguration:[LKImageConfiguration defaultConfiguration]]; &#125;); return instance;&#125; 先看看这个cacheManager.LKImageCacheManager维护了一个LKImageCache的实例的数组。看过源码发现。这个是一个基类,有两个个不同的实现类LKImageMemoryCache,LKImageSmartCache,不过你也定义自己的Cache类型。在LKImageManager的- (void)setConfiguration:(LKImageConfiguration *)configuration方法中添加了对应的Cache: 123456LKImageCacheManager *cacheManager = self.cacheManager; [cacheManager unregisterAllCache]; for (LKImageCache *cache in configuration.cacheList) &#123; [cacheManager registerCache:cache]; &#125; 而在LKImageCacheManager中的- (void)cacheImage:(UIImage *)image forRequest:(LKImageRequest *)request中就是调用了对用的Cache列表的对应的Cache方法，LKImageCache的子类来实现自己的- (void)cacheImage:(UIImage *)image forRequest:(LKImageRequest *)request方法就行了。我们来看下LKImageKit本身提供的两个Cache的方法: LKImageMemoryCache12345678910111213141516171819202122232425262728293031- (void)cacheImage:(UIImage *)image URL:(NSString *)URL&#123; NSString *key = [self keyForURL:URL]; ImagePointer *ptr = NULL; auto it = imageMap.find([key cStringUsingEncoding:NSUTF8StringEncoding]); if (it == imageMap.end()) &#123; ImageNode *node = new ImageNode(); ptr = new ImagePointer(); node-&gt;image = image; node-&gt;key = [key cStringUsingEncoding:NSUTF8StringEncoding]; ptr-&gt;it = FIFOQueue.insert(FIFOQueue.end(), node); imageMap[node-&gt;key] = ptr; if (FIFOQueue.size() &gt; self.maxLengthForFIFO) &#123; ImageNode *node = *FIFOQueue.begin(); FIFOQueue.pop_front(); auto it = imageMap.find(node-&gt;key); delete it-&gt;second; delete node; imageMap.erase(it); &#125; &#125; else &#123; ptr = it-&gt;second; (*ptr-&gt;it)-&gt;image = image; [self visit:key]; &#125; [self limitCacheSize];&#125; 这个类中可以看到一个map&lt;string,ImagePointer *&gt; imageMap实例。在- (void)cacheImage:(UIImage *)image URL:(NSString *)URL中用图片的地址当做key来在map中寻找对应的ImagePointer指针，如果没有找到，就新建一个ImageNode和ImagePointer指针，设置node的image为image,然后在FIFOQueue的列表的尾部添加这个node。然后查看队列的大小时候超出了预定的阈值,如果超过就按照先进先出的策略pop掉第一个，并且在map中也删除掉这个迭代器类型的数据。同事在堆上把node和pointer都free掉。 这边其实基本可以看出map和list的作用了，map是为在O(1)的时间复杂度内找到对应的数据。而list是为了控制缓存的大小. 然后在看下如果map中存在这个key的时候的操作。就是更新下这个key对应的图片，然后调用visit方法，最后调用limitCacheSize方法 先看下visit方法: 1234567891011121314151617181920212223242526- (void)visit:(NSString *)key&#123; auto it = imageMap.find([key cStringUsingEncoding:NSUTF8StringEncoding]); if (it == imageMap.end()) &#123; return; &#125; ImagePointer *ptr = it-&gt;second; ImageNode *node = *ptr-&gt;it; if (ptr-&gt;isLRUQueue) &#123; LRUQueue.erase(ptr-&gt;it); ptr-&gt;it = LRUQueue.insert(LRUQueue.end(), node); &#125; else &#123; ptr-&gt;isLRUQueue = true; FIFOQueue.erase(ptr-&gt;it); ptr-&gt;it = LRUQueue.insert(LRUQueue.end(), node); &#125; if (LRUQueue.size() &gt; self.maxLengthForLRU) &#123; [self clearLastOneInLRU]; &#125;&#125; 这个时候先查看这个ImagePointer的Node是不是在LRUQueue这个列表里边，如果在的话就删除之后再插入到列表的最后去，如果不在的话就在FIFOQueue中删除掉这个node,重新加入到LRUQueue中去，之后再根据LRUQueue的大小来clean下,我们也能想到既然最新visit的是放到最尾部，那么做clean操作的时候肯定就是清除头部了. 然后我们看下limitCacheSize方法,同样的是很简单的根据map中缓存的图片的尺寸x4之后的大小来和阈值比较，在做情况LRUQueue和FIFOQueue的操作。 这样的话，我们也是能简单的想到LRUQueue的作用了，其实就是一层保证越是后边被使用的图片越是不容易被从缓存中清除出去的机制。不过这边代码里边有个疑问的地方在清除数据的时候会先清除LRUQueue： 1234567891011- (void)clearLastOne&#123; if (LRUQueue.size() &gt; 0) &#123; [self clearLastOneInLRU]; &#125; else &#123; [self clearLastOneInFIFO]; &#125;&#125; 感觉上是先FIFOQueue是不是更好一点，毕竟在FIFO中的图片按代码来说只是被用了一次。哪位大佬了解的可以说下 LKImageSmartCache这个比较简单，说使用一个NSMapTable来管理缓存数据就不多说了。 缓存的逻辑基本就是这样啦。好像在这边并没有看到README中所说的磁盘缓存 在看下图片加载的代码,主要是看看发送请求的代码(这边的请求不一定是网络请求。是对图片加载的一种封装，可以想象成操作系统对IO的封装一样) 1234[self.imageManager sendRequest:self.request completion:^(LKImageRequest *request, UIImage *image, BOOL isFromSyncCache) &#123; [wself handleRequestFinish:request image:image isFromSyncCache:isFromSyncCache]; &#125;]; 这个方法正如他的category写的那样是一个语法糖. 12345- (void)sendRequest:(LKImageRequest *)request completion:(LKImageManagerCallback)callback&#123; request.managerCallback = callback; [self sendRequest:request];&#125; 在sendRequest方法中可以看到调用了- (BOOL)checkAndLoadCache:(LKImageRequest *)requestLV0这个方法来加载缓存。我们会看到会在mainqueue中同步的运行block.这边可以看到一个GCD的方法if (dispatch_queue_get_label(queue) == dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)),用于判断当前的queue是否是指定的queue.然后在block中会调用CacheManager的- (UIImage *)imageForRequest:(LKImageRequest *)request continueLoad:(BOOL *)continueLoad方法: 12345678910111213- (UIImage *)imageForRequest:(LKImageRequest *)request continueLoad:(BOOL *)continueLoad&#123; UIImage *image = nil; for (LKImageCache *cache in self.cacheList) &#123; image = [cache imageForRequest:request continueLoad:continueLoad]; if (image) &#123; break; &#125; &#125; return image;&#125; 可以看出其实就是在配置的CacheList中来查找对应的图片了，对应的实现就是也比较简单了，比如MemoryCache就是在map中find这个key对应的数据，SmartCache就是在NSMapTable中找对用的数据,不过这边的continuedLoad参数在源码中提供的两个Cache中都是没有被使用的参数，不知道是什么考虑。获取到缓存之后就会调用request的managerCallback这个block(就是用户传入的回调),同时还会把childRequests的callback也调用一遍，这个requestlist我们以后再来分析:) 到目前为止基本分析完了缓存这块的内容啦。 以后会分下下LKImageRequest和他的子类 == 未完待续 ==]]></content>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B站AV号转音频程序]]></title>
    <url>%2F2018%2F03%2F09%2FB%E7%AB%99AV%E5%8F%B7%E8%BD%AC%E9%9F%B3%E9%A2%91%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[上B站的时候有好多弹幕都是在求BGM的。于是就想不如咱自己写一个东西来分离视频里边的音视频。把音频给抽出来：) 分析基本想法就是分成3步来做啦 准备阶段—&gt;通过av号获取到视频的地址 下载阶段—&gt;获取到下载地址之后下载视频 分离阶段—&gt;分离视频中的音频保存到单独的文件 很简单明确。然后就是找对用的技术啦，最主要的就是分离阶段的技术。我这边选择ffmpeg, 通用的解决方案啦。然后既然是用ffmpeg就要用c/c++来实现比较方便了。最终确定的方案就是这样的: 网络请求—&gt; cURL JSON —&gt; rapidjson 音视频 —&gt;ffmpeg 编码 ffmpeg 下载，make ， make install 建立CMakeList.txt 我是在mac上写的。所有需要加上一些变量，下边的是我的cmakelist文件 1234567891011121314151617cmake_minimum_required(VERSION 3.5)project(BiliBg)#mac/ios build need add some xcode libset(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; -v -std=c++11 -stdlib=libc++ -framework OpenGL -framework AppKit -framework Security -framework CoreFoundation -framework CoreVideo -framework CoreMedia -framework QuartzCore -framework CoreFoundation -framework VideoDecodeAcceleration -framework Cocoa -framework AudioToolbox -framework VideoToolbox -framework OpenCL -I/usr/local/include -L/usr/local/lib/ -I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include -L/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/")set(SOURCE_FILES main.cpp iomodule/BiliMovieDownloader.cpp iomodule/BiliMovieDownloader.h videomodule/BiliMovieDumux.cpp videomodule/BiliMovieDumux.h)add_executable(BiliBg $&#123;SOURCE_FILES&#125;)target_link_libraries(BiliBg curl)target_link_libraries(BiliBg bz2)target_link_libraries(BiliBg z)target_link_libraries(BiliBg iconv.2.4.0)target_link_libraries(BiliBg /usr/local/lib/libavcodec.a)target_link_libraries(BiliBg /usr/local/lib/libavformat.a)target_link_libraries(BiliBg /usr/local/lib/libswscale.a)target_link_libraries(BiliBg /usr/local/lib/libavdevice.a)target_link_libraries(BiliBg /usr/local/lib/libavutil.a)target_link_libraries(BiliBg /usr/local/lib/libswresample.a) 代码其实比较简单分成两个模块： io模块 负责请求，解析，下载 音视频分离模块 读取视频文件获取解码器，分离音视频 代码地址：这里 TODO: (有空的时候有可能做吧) 添加时间参数。分离特定时间的bgm]]></content>
      <tags>
        <tag>FFMPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake实战2]]></title>
    <url>%2F2018%2F03%2F07%2FCMake%E5%AE%9E%E6%88%982%2F</url>
    <content type="text"><![CDATA[4 编写CMakeLists文件这一章主要覆盖了为你的软件编写CMakeLists文件一些基础，我们将会学习到你在大多数项目中遇到的所有的基本命令和一些问题,也会学习下周末把现有的UNIX或者Windows项目转换到CMake上来，因为CMake能处理非常复杂的项目，所以大多数项目中你会发现这一章的内容完全够用啦，CMake是被CMakeLists文件驱动的，CMakeList文件决定一切，比如Cache中的值，需要被编译的文件。最后会讨论下怎么让CMakeLists文件健壮并且可维护，基础的语法和关键概念都已经在上边的章节说过了，这一章将张开这些概念并且引入一些新的东西 4.1 CMake 语法CMakeLists文件遵守一个简单的语法规则(注释，命令，空白符)，注释是从一个#开始的知道行尾，命令是由命令名称，小括号，空白符分割的参数组成的，含有空白符的参数用双引号括起来，反斜线可以做转移符，后边的一些列子会帮你解决语法上困惑，你可能回想CMake为什么不用先用的语言的语法来实现，比如Python啥的，主要的母的是想让CMake不要依赖其他的东西来运行，要是依赖了这些语言的话，安装就会很大,也需要依赖特定版本的语言，我们自己干的话就没有性能和兼容问题啦 4.2 基本命令上一章已经介绍了蛮多基础的基础命令了，这一章将会重新来看下并且要展开来讲下，第一个命令是顶层CMakeLists文件要包含的PROJECT命令，这个命令不仅可以给项目命名还能指定工程使用的语言他的语法如下: 1project (projectname [CXX] [C] [Java] [NONE]) 如果没有指定语言，CMake默认会支持C和C++，如果指定了NONE，CMake将会不包含任何语言支持，当CPP被支持的时候C的支持也会加载的 对于项目中每一个project命令,CMake会创建一个顶层的IDE的project文件，这个项目会包含CMakeLists文件中的所有Target，添加子目录需要使用add_subdirectory命令，如果EXCLUDE_FROM_ALL选项被用在add_subdirectory命令中的话，生产的项目将不会出现在顶层的Make文件或者IDE的项目文件中。这个功能在你想要让你的子目录的项目和你的主项目没啥关系的时候很有用,举个栗子，假设你的工程有很多例子项目,你可以使用这个功能来为你的例子生产编译文件，但是在正常的编译中不会包含例子目录 set命令可能是用的最多的命令，他可以用来定义和修改变量和列表，和set相对的，remove和separate_arguments命令，remove命令可以用来从变量列表里边删除值，separate_arguments可以用来把一个单一的变量值用空白分割成一个列表 add_executable和add_library命令是用来定义库和可执行文件的编译和源码的，加的源码可以包含头文件，反正基于makefile的generators是会简单的省略掉 4.3 流控制在很多方面写一个CMakeList文件就和写一段程序是一毛一样的，所以和其他的编程语言一样，CMake为咱提供了控制流结构： 条件判断语句(例如:if等) 循环结构(例如:foreach和while等) 程序流程定义(例如macro和function等) 首先我们看下if命令，在很多方面和在其他编程语言是一样的，计算表达式的值，根据结果运行命令的体内的代码或者运行可选的else中的代码。举个栗子： 12345if (FOO)# do something hereelse (FOO)# do something elseendif(FOO) 一个你可能注意到的不一样的地方就是if中的条件在else和endif中都会重复写一次，这个是可选的，在这本书里边你将看到两种风格的代码，你可以自己选择： 12345if (FOO)# do something here else()# do something elseendif() if命令有一些使用的限制，它不支持一些像${FOO} &amp;&amp; ${BAR} || ${FUBAR}这样的C类型的表达式，作为替代，它支持一些表达式的子集，大多数情况下，这些就够啦，if命令支持: if(variable) 如果变量的值不是空，0，FALSE, OFF或者NOTFOUND if(NOT variable) 如果变量的值是空，0， FALSE, OFF或者NOTFOUND if(variabl1 AND variable2) 变量同时为真，表达式为真 if(varibale1 OR variable2) 变量一个为真，表达式为真 if(COMMAND command-name) 如果给定的命令名称是一个可调用的命令，表达式为真 if(DEFINED variable) 如果变量被set过，不管这个值是多少，表达式为真 if(EXISTS file-name) if(EXISTS directory-name) 如果文件或者目录存在，表达式为真 if(IS_DIRECTORY directory-name) if(IS_ABSOLUTE name) 如果名称是一个目录或者一个绝对路径，表达式为真 if(name1 IS_NEWER_THAN name2) 最后修改时间文件1比文件2更新，表达式为真 if(variable MATCH regex) if(string MATCH regex) 如果给定的字符串或者变量的值符合正则，表达式为真 EQUAL,LESS,和GREATER可以用作数值比较 STRLESS,STREQUAL,和STRGREATER 可以用作字符字面值的比较 VERSION_LESS,VERSION_EQUAL和VERSION_GREATER可以用来做像major.[.minor[.patch.[.tweak]]]这样的版本比较，像C/C++一样，这些表达式可以组合起来使用来创建更多复杂的比较，举个栗子，考虑下边的这些情况: 1234567891011121314151617181920212223242526272829if ((1 LESS 2) AND (3 LESS 4)) message(&quot;sequence of numbers&quot;)endif()if (1 AND 3 AND 4) message(&quot;series of true values&quot;)endif(1 AND 3 AND 4)if (nor 0 AND 3 AND 4) message (&quot;a flase value&quot;)endif(NOT 0 AND 4 AND 4)if (0 OR 3 AND 4) message (&quot;or statements&quot;)endif (0 OR 3 AND 4)if (EXISTS $&#123;PROJECT_SOURCE_DIR&#125;/help.txt AND COMMAND IF) message(&quot;help text&quot;)endif （EXISTS $&#123;PROJECT_SOURCE_DIR/help.txt AND COMMAND IF&#125;）set (foobar 0)if (NOT DEFINED foobar) message (&quot;foobar is not defined&quot;)endif (NOT DEFINED foobar)if (NOT DEFINED fooba) message (&quot;fooba not defined&quot;)endif 在复合的if语句中，有一个指定运算符的执行的顺序，在下边的表达式中，NOT会在AND之前运行，而不是相反的顺序，因此表达式的结果是false，打印的语句也不会执行，如果AND先运行的话，结果就是true了： 123if (NOT 0 AND 0) message (&quot;this line is nerver executed&quot;)endif (NOT 0 AND 0) CMake 定义了操作符的执行顺序，比如括号内的表达式先支持性，EXISTS,COMMAND,DEFINED和相似的前缀运算符先执行，然后是想EQUAL,LESS,GREATER,STREQUAL,STRLESS,STRGREATER和MATCHS运算符，之后运行NOT运算符，最后是AND和OR,哪些具有相同执行级别的运算符比如AND和OR将会从左到右执行，一旦所有的表达式都执行并得到整个表达式的结果，CMake将ON,1,YES,TRUE,Y当做true,将OFF,0,NO,FALSE,N,NOTFOUND,*-NOTFOUND,IGNORE当做false，计算的值的大小写不敏感的，所有true,True和TRUE是相同的 咱们现在再来看下另外一种控制流命令，foreach,while,macro和function命令是减少你CMakeLists文件大小并保证可维护性的的最好的命令，foreach命令可以让你在一个列表中重复运行一组CMake命令，我们看看下边VTK中的栗子： 12345678910111213141516foreach (tfile TestAnisotropicDiffusion2D TestButterworthLowPass TestButterworthHighPass TestCityBlockDistance TestConvolve )add_test ($&#123;tfile&#125;-image $&#123;VTK_EXECUTABLE&#125; $&#123;VTK_SOURCE_DIR&#125;/Tests/rtImageTest.tcl $&#123;VTK_SOURCE_DIR&#125;/Tests/$&#123;tfile&#125;.tcl -D $&#123;VTK_DATA_ROOT&#125; -V Baseline/Imaging/$&#123;tfile&#125;.png -A $&#123;VTK_SOURCE_DIR&#125;/Wrapping/Tcl )endforeach (tfile) foreach的第一个参数是在循环中使用的变量名。剩余的参数是用来做循环的列表的值，在栗子中的foreach循环只是一个CMake命令add_test,在foreach的循环体内部任何时候都可以使用循环变量(tfile)来指代列表中在当前迭代中的元素，在第一次迭代中，${tfile}将会被TestAnisotropicDiffusion2D替换，下一个迭代${tfile}将会被TestButterworthLowPass替代,foreach将会继续循环知道所有参数都被处理完为止 值得一提的是，foreach可以嵌套使用，循环变量在任意表达式之前被替换成列表中的值，这意味着，在foreach的循环体中可以使用循环变量来创建新的变量名，下边的代码循环变量tfile被展开，然后和_TEST_RESULT组合起新的变量，新变量的名字被展开和并当场if的条件表达式来运算: 123if ($&#123;$&#123;tfile&#125;_TEST_RESULT&#125; MATCHES FAILED) message (&quot;Test $&#123;tfile&#125; failed&quot;)endif() 原文中if表达式的参数是${${tfile}}_TEST_RESULT} MATCHES FAILED,应该是有问题的 while命令提供了一个基于条件判断的循环，条件表达式的格式和if是一样的，考虑下边CTest中使用的栗子，注意CTest在内部更新了CTEST_ELAPSED_TIME的值： 12345678################################################################################# run paraview and ctest dashboards for 6 hours# while ($&#123;CTEST_ELAPSED_TIME&#125; LESS 36000) set (START_TIME $&#123;CTEST_ELAPSED_TIME&#125;) ctest_run_script (&quot;dash1_ParaView_vs71continuous.cmake&quot;) ctest_run_script (&quot;dash1_cmake_vs71continuous.cmake&quot;)endwhile() foreach和while命令可以让你处理重复的任务，macro和function命令支持把散落在CMakeLists文件中的重复的任务打包。一旦他们被定义，任何在定义之后CMakeLists文件都可以使用他们 CMake中的function和C/C++中的function很相似，你可以传递参数，在方法内部参数变成了变量，就像其他的标准变量ARGC,ARGV,ARGN和ARGV0,ARGV1等等，在function内部，你就在一个新的变量作用域中了，有点像你使用add_subdirectorty命令进入了一个新的子目录使用新的变量作用域一样，所有定义的变量在方法调用中还是被定义的，但是任何在对这些变量的改变或者新的变量都只存在于方法内部，当方法返回之后，这些都会消失不见，更简单点说，当你调用一个方法是，一个新的变量作用域被push到栈顶，当你从方法返回时，作用域被pop掉 function 的第一参数是方法名称，剩下的参数都是function的正式参数啦： 123456789function (DetermineTime _time) # pass the result up to whatever invoked this set ($&#123;_time&#125; &quot;1:23:45&quot; PARENT_SCOPE)endfunction()DetermineTime( current_time ) if (DEFINED current_time) message(STATUS &quot;the time is now: $&#123;current_time&#125;&quot;)endif 注意这个栗子中的_time被用作返回值的名称，set命令使用_time的值。这个栗子中就是current_time,最后set命令使用PARENT_SCOPE选项来设置变量的值到父作用域 macro的定义和调用在默写方面是和function是一样的，主要的不同点在于，macro没有push和pop新的变量作用域，并且参数不是作为变量，而是作为字符串在运行前被替换的，这些很像C/C++里边的方法和宏的区别。 第一个参数作为macro的名字，后边的作为参数 1234567891011#define a simple macromacro (assert TEST COMMENT) if (NOT $&#123;TEST&#125;) message (&quot;Assertion failed: $&#123;COMMENT&#125;&quot;) endif(NOT $&#123;TEST&#125;)endmacro(assert)#use the macrofind_library (FOO_LIB foo /usr/local/lib)assert ($&#123;FOO_LIB&#125; &quot;Unable to find library foo&quot;) 上边的简单例子中创建了一个叫做assert的宏，这个宏使用了两个参数，第一个是用于测试的值，第二个是如果测试失败打印的字符串，macro的宏体内是一个简单的if命令和一个message命令。macro用一个endmacro来作为结束，macro可以像一个普通的命令一样被调用，在上边的例子中，如果FOO_LIB没找到，就会显示一条信息来表示错误情况 macro命令同样支持定义使用参数列表的宏，当你想要用可变参数或者多签名(???)时会很有用。可变参数可以使用ARGC,ARGV0,ARGV1等来引用，ARGV0表示宏的第一个参数，ARGV1代表下一个，以此类推，你甚至可以使用最少的正式参数和可变参数.下边举个栗子： 1234567891011121314151617# define a macro that takes at least two arguments# (thr formal arguments) plus an optional third argumentmacro (assert TEST COMMENT) if (NOT $&#123;TEST&#125;) message (&quot;Assertion failed :$&#123;COMMENT&#125;&quot;) # if called with three arguments then also write the # message to a file specified as the third argument if ($&#123;ARGC&#125; MATCHES 3) file (APPEND $&#123;ARGV2&#125; &quot;Assertion failed: $&#123;COMMENT&#125;&quot;) endif ($&#123;ARGC&#125; MATCHES 3) endif (NOT $&#123;TEST&#125;)endmacro (assert)#use the macrofind_library (FOO_LIB foo /usr/local/lib)assert ($&#123;FOO_LIB&#125; &quot;Unable to find library foo&quot;) CMake有连个命令用于打断执行流，break命令可以打断foreach和while循环的正常执行，return命令将从方法或者listfile的正常结束之前返回 在这个栗子中，TEST和COMMENT是两个必备的参数，像这个例子中一样这些必备参数可以使用名称来引用,也可以使用ARGV0,ARGV1,如果你想要把参数当成列表来使用，你可以使用ARGV和ARGN变量，ARGV(相对于ARGV0,ARGV1等等)是一个宏的全参数列表，ARGN是正式参数之后的参数列表，在宏体内，你可以使用foreach命令来遍历ARGV或者ARGN 4.4 正则表达式有些CMake命令比如if和string会使用正则或者使用正则作为一个参数，在简单的模式下，一个正则是一系列的字符用于匹配搜索确切的字符，不过，很多时候我们不知道确切的字符串是什么，或者只知道字符串的开头和结尾，因为有好几种不同的方式来指定正则，CMake的标准制动如下: 正则可以使用标准的字母数字组合来指定，并使用下边的这些元字符： ^ 匹配以一行或者一个字符串的开始 $ 匹配一行或一个字符串的结尾 . 匹配一个处理换行外的任意字符 [] 匹配中间的任意字符 [^ ] 匹配不在符号中间的任意字符 [ - ] 匹配范围 * 匹配前一个模式0次或多次 + 匹配前一个模式1次货多次 ? 匹配前一个模式0次或1次 () 保存匹配的表达式，后边可以再用 (|) 匹配|左边或者右边的模式 注意上边的这些元字符可以在单一的模式中使用不止一次用来创建一个复杂的搜索模式，举个栗子，[^ab1-9]匹配任意的不是以a,b或者数字开头的字符序列,下边的栗子可以帮助我们了解正则的用法: ^hello只匹配哪些以hello开头的字符串，他可以匹配&quot;hello there&quot;, 但是不匹配&quot;hi,\n hello there&quot;. long$ 匹配 long结尾的字符串，他匹配so long,不匹配long ago t..t..g 匹配一个t然后两个字符，另一个t和连个字符，最后是一个g,可以匹配testing或者test again, 但是不能匹配toasting. [1-9ab]匹配1-9数字和a,b, 他可以匹配hello 1或者begin 但是不匹配no-match [^1-9ab]匹配任意的非1-9的数字和非a,b的字母，他不匹配1ab2和b2345a,但是可以匹配no-match br*匹配以一个b开头跟着0个或多个r并且以空格结尾的字符串，他可以匹配brrrrr和b,但是不能匹配brrh br+匹配以b开头跟着一个或多个r并且以空格结尾的字符串，他可以匹配brrrrr和br，但是不匹配b或者brrh br?匹配以一个b开头跟随0个或者1个r并且以空格结尾的字符串，他可以匹配br和b，但是不匹配brrrrr或者brrh (..p)b匹配以pb结尾，任意两个字符在第一次遇到p的时候，可以在rep drepaqrepb搜索到repb, (..p)a可以在repa drepb qrepb中搜索到repa qrepb d(..p)匹配那些以d开头，以p结尾并且中间包含两个字符，并且这两个字符与第一次遇到p之前的是相同的，他可以在rep drepa qrepb中搜索到drepa qrepb 4.5 检查CMake的版本CMake是一个不断进化的程序，新的功能和命令随着新版本不停的发布，这就会导致一个问题，你可能想要使用一个在最新版本中的命令，但是在旧版本中却不支持，有好几种方法可以处理这种问题，一种选择就是使用if命令来检查命令是否存在，举个栗子： 123456# test if the command existsif (COMMAND some_new_command) #use the command some_new_command (ARGS...)endif(COMMAND some_new_command) 上边的方法大多数情况下都是适用的，但是如果你想要得到更多的信息，你可以使用CMAKE_VERSION变量来测试当前正在运行的CMake的版本，举个栗子： 12345# look for newer version of CMakeif ($&#123;CMAKE_VERSION&#125; VERSION_GREATER 1.6.1) #do something special hereendif () 当编写CMakeLists文件的时候你可以指定不支持旧版本的CMake。要使用这个功能只需要把下边的命令放在CMakeLists文件的最上边就行啦: 1cmake_minimum_required (VERSION 2.2) 这一行指定了，要在你的项目上运行CMake，版本必须大于等于2.2, 如果在老版本上运行，会显示一条错误信息来提示你需要的CMake的最小版本号 最后，有些情况下，新版本会废弃掉一些命令，这个时候你可以使用CMake policies 下边的4.7会讲到 4.6 使用模块CMake支持代码复用，CMakeLists可以使用可复用的模块。CMake对于这些复用的代码称作section，可以在CMake安装的模块子目录中找到. 模块就是简单的把CMake命令放在一个文件里边。举个栗子，之后可以使用#include命令引入进来，举个栗子，下边的命令将会引入FindTCL模块，并添加Tcl库到FOO目标中:12include (FindTCL)target_link_libraries (FOO $&#123;TCL_LIBRARY&#125;) 模块的位置可以使用绝对路径指定，或者可以让CMake自己去寻找，CMake会在CMAKE_MODULE_PATH指定的地址中寻找模块，如果没有找到，会在CMake的模块目录中寻找。这样项目可以覆盖CMake提供的模块来适配自己的需求，模块可以分成下边的几种主要的类型: Find Modules 这些模块决定了软件的组件比如头文件或者库的位置 System Introspection Modules 这些模块测试系统的一些属性，比如float的大小，ANSI C++ 流的支持等等 Utility Modules 这些模块提供了额外的一些功能，比如一个CMake项目基于另外一个，和一些其他的方便的路由 现在让我们来详细的看下这三种模块,CMake引入了大量的Find Modules，他们的目的是定位软件的组件，比如头文件或者库文件，如果不能找到，他们会提供一个cache件让用户可以设置需要的属性，考虑下边的用于寻找PNG库的模块：123456789101112131415161718192021222324252627282930313233343536# # find the native PNG includes and library## this module defines# PNG_INCLUDE_DIR ,用于寻找 png.h 等# PNG_LIBRARIES 用于链接的PNG库# PNG_DEFINITIONS 你应该在编译引入png库的代码文件之前调用add_definitions ($&#123;PNG_DEFINITIONS&#125;) # PNG_FOUND 如果是false，不要使用PNG# 被定义了,不过一般情况下不用# PNG_LIBRARY 哪里寻找PNG Library# None of the above will be defined unless zlib can be found# PNG depends on Zlibinclude (FindZLib.cmake)if (ZLIB_FOUND) find_path (PNG_PNG_INCLUDE_DIR png.h /usr/local/include /usr/include) find_library (PNG_LIBRARY png /usr/lib /usr/local/lib ) if (PNG_LIBRARY) if (PNG_PNG_INCLUDE_DIR) # png.h includes zlib.h .Sigh set (PNG_INCLUDE_DIR $&#123;PNG_PNG_INCLUDE_DIR&#125; $&#123;ZLIB_INCLUDE_DIR&#125;) set (PNG_LIBRARIES $&#123;PNG_LIBRARY&#125; $&#123;ZLIB_LIBRARY&#125;) set (PNG_FOUND &quot;YES&quot;) if (CYGWIN) if (BUILD_SHARED_LIBS) # NO need to define PNG_USE_DLL here, because it&apos;s default for cygwin else (BUILD_SAHRED_LIBS) set (PNG_DEFINITIONS -DPNG_STATIC) endif(BUILD_SHARED_LIBS) endif (CYGWIN) endif() endifendif() 头部的文档已经说明了模块的功能和模块定义的变量,他引入了另一个模块–FindZLIB模块，他会确认Zlib库是不是已经安装了，再然后，如果ZLib被找到了，find_path命令用来定位PNG的头文件，第一个用于保存结果，第二个参数是需要找的头文件的名字，剩余的参数是用于寻找这个头文件的路径，如果在系统目录中没有找到，变量会被设置成PNG_PNG_INCLUDE_DIR-NOTFOUND,用户可以修改这个值 注意搜搜PNG库的路径可以包含硬编码的目录，注册条目，使用其他CMake变量创建出来不的目录，下一个命令find_library寻找PNG库真正位置。这个命令会检查来寻找正确的库名，比如Linux上在名称前添加lib,在名称后边添加.so 在find运行之后，设置了一些CMake变量，使用FindPNG模块的开发者可以使用这些变量(比如include路径，库的名称)，最后PNG_FOUND设置正确让使用的开发者知道PNG库被正确的找到了 这个结构在CMake寻找模块中中是正常操作，通常都很短，但是在默写情况下，比如FindOpenGL可能有几页长，他们通常是独立于其他模块的，但是没有使用其他模块的限制 系统自省模块可以提供关于目标平台或者编译器的信息，模块可以提供关于目标平台或者编译器的信息, 很多这种模块都有一个以Test或者Check的前缀，比如TestBigEndian和CheckTypeSize，很多系统自省模块实际上是尝试去编译代码来判断结果是否正确，这些情况下，源码文件的名称和模块经常是一样的，只是加上一个.c或者.cxx的后缀，在第五章会详细说说系统自省模块 CMake包含一些工具模块帮助你更简单的使用CMake，CMakeExportBuildSettings和CMakeImportBuildSettings提供了帮助检验两个不同的C++项目是否使用看了相同的编译器和参数的工具，CMakePrintSystemInfomation模块打印出在debug程序是有用的关键的CMake设置信息 SWIG中使用CMake一个很好的使用模块的栗子就是看看怎样使用SWIG把你的C/C++代码包装成另外一种语言.SWIG(Simplified Wrapper and Interface Generator)就是一个创建胶水语言（不翻了），CMake可以使用find_package命令支持SWIG.尽管SWIG可以做CMake中作为客户话的命令使用。不过SWIG包提供了一些宏来是创建SWIG项目相对简单点，要使用这些宏，首先使用find_package命令SWIG的名称做为参数，然后你需要引入]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake实战]]></title>
    <url>%2F2018%2F03%2F07%2FCMake%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[2.3 cmkae基本语法和语法使用cmake很简单,build过程被创建的CMakeLists.txt文件所控制,包含在子目录中的CMakelists.txt文件，CMakeLists文件应该描述了项目的结构,基本的命令的形式如下: command (args ...) args 是用空白符分开的参数列表(参数如果包含空格，就用双引号包含下),CMake是大小写不敏感的(2.2之后)所以你可以使用command或者COMMAND CMake支持简单的变量比如字符串或者字符串列表，使用${变量}来引用, 多个参数可以使用set命令打包到列表中去，所有的其他命令会展开用空白符分隔来展开列表 举个栗子 set (Foo a b) 命令的结果是将a,b,c包进Foo变量，所以如果传递Foo到另外一个命令COMMAND(${Foo})和COMMAND(a b c)是一样的 如果你想要将列表传递给命令作为一个单独的参数，只需要简单的用双引号包括以下就行 再举个栗子 COMMAND(&quot;${Foo}&quot;) 和 COMMAND(&quot;a b c&quot;)是一样的效果 系统环境变量和Windows的注册变量(注册表啥的吧，不懂:&lt;)在CMake中都可以访问，要访问系统环境变量使用$ENV{变量}语法，CMake还可以在很多不同的命令中使用[HKEY_CURRENT_URSER\\Software\\path1\\path2;key]引用注册变量,这些路径是注册树和key 2.4 CMake Hello World咱们来看个简单的吧:), 为了从源码中编译出一个可执行文件，CMake需要一个CMakeLists.txt文件，文件中需要包含两行: project (Hello) add_executable (Hello Hello.c) 为了编译出Hello可执行文件，咱们运行CMake来生成Makefiles或者巨硬的项目文件。 project命令标识了结果的工作空间应该叫什么 add_executable命令向编译程序添加了一个可执行的目标 如果你的项目需要不是特别多的源文件，只需要简单的修改下add_executable就好啦: add_executable(Hello Hello.c File2.c File3.c File4.c) add_executable只是CMake众多命令中的一件。咱们来看看一个更不清真的栗子: 1234567891011121314151617cmake_minimum_required(2.6)project (HELLO)set (HELLO_SRCS Hello.c File2.c File3.c)if (WIN32) set (HELLO_SRCS $&#123;HELLO_SRCS&#125; WinSupport.c) else () set (HELLO_SRCS $&#123;HELLO_SRCS&#125; UnixSupport.c) endif ()add_executable (HELLO $&#123;HELLO_SRCS&#125;)#look for thr Tcl libraryfind_library (TCL_LIBRARY NAMES tcl tcl84 tcl83 tcl82 tcl80 PATHS /usr/lib /usr/local/lib)if (TCL_LIBRARY) target_link_library(Hello $&#123;TCL_LIBRARY&#125;) endif () 这个栗子里边使用set命令来打包参数列表，使用if命令来添加各自平台的支持文件，最后使用了add_executable命令来编译可执行文件，find_library命令搜索TCL_LIBRARY使用了不同的名称和不同的路径，使用一个if命令来判断TCL_LIBRARY是否找到，如果找到了就把他link到可执行文件的target中，注意#作为一个注释来使用，从#到行尾都是注释部分 2.5 如何运行CMake只要你系统里边装了CMake，使用它来编译项目很简单，CMake用两个主要的目录来编译项目:源码目录和二进制目录。源码目录里边包含源码和CMakeLists.txt文件。二进制目录就是放可执行文件，库，目标文件这些东西的，一般来说，CMake不会在源码目录里边写东西，只在二进制目录里边干活，如果你想让CMake在源码目录里边写东西的话:&lt;(一般不要这么做吧，不明白什么时候需要这么干)，就把源码目录和二进制目录设置成一样的就妥了这个就是–in-source-build。相对的就是out-source-build。 CMake在所有平台上两种方式都是资瓷的。就是说你用out-source-build的时候你可以简单地删除掉所有编译期间生产的文件。拥有不同的编译路径和源码路径让资瓷对同一份代码的多个编译很简单，这个功能在你想要用不同的编译选项编译同一份代码的时候很有用。CMake还有一个QT的GUI(蛤，我为什么要用这个，反正我不用，我就不翻了) 在控制台运行CMake在命令行上，CMake可以当成一个交互的问答式的会话或者是一个无交互的程序。加上-i参数就可以启动交互模式，交互模式下Cmake将会为每一个参数询问你。CMake将会提供有效的默认值。CMake将问完所有的问题然后停止 使用无交互模式编译项目在不需要参数或者很少参数的时候很简单。对于大型的项目像VTK,使用gui或者cmake -i比较推荐。 使用CMake的无交互模式，首先cd到你想要放二进制的目录,in-source-build的话就直接运行cmake,加上-D来传递编译选项。out-source-build的话同样的操作，只是需要你添加上源文件的目录作为cmake的参数。然后使用make命令来编译你的项目，有些项目会包含 install 目标，你可以使用make install来安装他们 指定编译器有时候在你的操作系统里边可能包好不止一个编译器或者编译器不在标准的路径下边，这个时候你告诉CMake你想要用的编译器在什么地方。有三种方法可以实现这个功能: generator可以指定编译器 设置环境变量参数 设置一个缓存实例 默写generator可以绑定在特定的编译器，例如宇宙第一IDE的generator就是绑定到VS的编译器的。基于Makefile的generator会尝试一个常用的编译器列表。一般这个列表可以在这些文件中找到: Modules/CMakeDeterminCCompiler.cmakeModules/CMakeDeterminCxxCompiler.cmake 这个列表可以被环境变量覆盖掉。 CC 环境变量用来指定C编译器 CXX 用来指定c++编译器 你可以使用——DCMake_CXX_COMPILER=cl直接在命令行上指定编译器。如果不设置这个的话，CMake会依次选择下边的这些编译器: c++ g++ CC aCC cl bcc xlC CMake开始运行并且选好编译器之后,你可以修改缓存选项CMAKE_CXX_COMPILER和CMAKE_C_COMPILER修改选择的编译器，不过这种做法是不推荐的，这么做的问题主要是项目可能是你的配置可能已经运行了一些基于编译器的测试来判断一些支持特性。修改了编译器之后可能会导致一些不正确的结果。如果你必须修改编译器。重在一个新的空的二进制目录中进行。编译器的flags和链接器同意可以使用环境变量来修改。设置LDFLAFGS将会为link flag初始化一个缓存值,同样的CXXFLAGS和CFLAGS将会初始化CMAKE_CXX_FLAGS和CMAKE_C_FLAGS 依赖分析CMake拥有一个强大的内置C/C++依赖分析能力,CMake还支持部分的Java和Fortran依赖分析，因为IDE支持和维护了依赖信息，CMake对这些编译系统放弃了这部分功能，但是，Makefiels是不了解怎么样去计算和维护依赖信息的，对于这些系统，CMake为C/C++/Fortran自动计算依赖信息，CMake自动生成和维护依赖信息，这些都是自动完成的，如果一个项目是用CMake配置的，用户主需要运行Make，CMake会帮你完成剩余的工作，对于多处理器系统CMake完全支持并行编译 尽管用户不需要知道CMake是如何工作的，不过看一下项目的依赖信息文件也没啥坏处:),为每一个target创建的依赖文件保存在这四个文件中： depend.make flags.make build.make DependInfo.cmake depend.make保存了目录中的所有目标文件的所有的依赖信息flags.make包含了编译的flags 这两个文件如果改变了，源码就会被重新编译 DependInfo.cmakes是保持更新信息更新，并且包含了项目中包括哪些文件和这些文件使用的语言最后编译依赖的规则保存在build.make中，如果依赖不是过期了，所有的依赖需要重新计算来保持信息永远是最新的 2.6 编辑 CMakeLists 文件CMakeLists文件可以用几乎任意的文本编辑器来编辑,有些编辑器比如Notepad++内置了语法高亮和缩进支持，神的编辑器和编辑器之神也内置了语法和缩进支持 这段没啥营养啦，反正我用vim… 2.7 为CMake设置初始值尽管CMake在交互模式下运行的很好，有时你也可能在没有GUI的时候设置下缓存条目，这种情况是很常见的当设置nightly dashboard(不明白这边)或者是你将创建很多编译树使用相同的cahce值，在这些情况下，CMake缓存可以以两种方式被初始化，第一种方式是使用CMake命令行下-DCACHE_VAR:TYPE=VALUE传递cache值 再举个栗子 考虑下边的nightly dashboard脚本: 12345678910#!/bin/tcshcd $&#123;HOME&#125;#wipe out the old binary tree and then create it againrm -rf Foo-Linuxmkdir Foo-Linuxcd Foo-Linux#run cmake to setup the cachecmake -DBUILD_TESTING:BOOL=ON &lt;etc...&gt; ../Foo#generate the dashboardctest -D Nightly 同样的方法可以用在windows的批处理文件上 第二种方式是创建一个文件用来被CMake -C选项来加载。这种情况下取代-D这种方式的是使用一个文件来使用CMake解析，这个文件的语法就是标准的CMakeLists语法，通常来说就是一系列的set命令像这样的： 12#Build the vtkHybrid kit alwaysset (VTK_USE_HYBRID ON CACHE BOOL "doc" FORCE) 还有一种方法是你想要设置一个变量然后隐藏他，用户不会改变这个值，用下边的命令可以实现 123#Build the vtkHybrid kit alwaysset (VTK_USE_HYBRID ON CACHE BOOL "doc" FORCE)mark_as_advanced (VTK_USE_HYBRID) 你可能会想直接编辑cache文件，或者去“初始化”一个项目通过给他一个初始的cache文件的方式，这有可能跑不出来，或者在以后出现问题，首先，CMake cahe的语法是修改的东西，第二，cache 文件包含了完整路径。 2.8 编译你的项目运行完了CMake之后就可以准备编译了。如果你的编译系统是基于make的，你就cd到你的二进制目录然后运行make就行啦，如果是IDE的话就加载生产的项目文件，然后你按你平时的操作来就行了 另外一种选择就是在命令行中使用CMake的编译选项，这个选项就是一个便利的工具让你在命令行编译你的项目运行下cmake -build你就知道怎么用了。 [不清楚的地方] nightly dashboard]]></content>
      <tags>
        <tag>CMake,Tools</tag>
      </tags>
  </entry>
</search>
